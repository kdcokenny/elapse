{
	"date": "2025-11-25",
	"commits": [
		{
			"sha": "c141960ada4869ee6a3bb8a665e75c0c18ad7f19",
			"message": "feat: Non-elbow arrow snapping and behavior changes (#9670)\n\n* Fixed point binding for simple arrows\n\nTests added\n\nFix binding\n\nRemove unneeded params\n\nUnfinished simple arrow avoidance\n\nFix newly created jumping arrow when gets outside\n\nDo not apply the jumping logic to elbow arrows for new elements\n\nExisting arrows now jump out\n\nType updates to support fixed binding for simple arrows\n\nFix crash for elbow arrws in mutateElement()\n\nRefactored simple arrow creation\n\nUpdating tests\n\nNo confirm threshold when inside biding range\n\nFix multi-point arrow grid off\n\nMake elbow arrows respect grids\n\nUnbind arrow if bound and moved at shaft of arrow key\n\nFix binding test\n\nFix drag unbind when the bound element is in the selection\n\nDo not move mid point for simple arrows bound on both ends\n\nAdd test for mobing mid points for simple arrows when bound on the same element on both ends\n\nFix linear editor bug when both midpoint and endpoint is moved\n\nFix all point multipoint arrow highlight and binding\n\nArrow dragging gets a little drag to avoid accidental unbinding\n\nFixed point binding for simple arrows when the arrow doesn't point to the element\n\nFix binding disabled use-case triggering arrow editor\n\nTimed binding mode change for simple arrows\n\nApply fixes\n\nRemove code to unbind on drag\n\nUpdate simple arrow fixed point when arrow is dragged or moved by arrow keys\n\nBinding highlight fixes\n\nChange bind mode timeout logic\n\nFix tests\n\nAdd Alt bindMode switch\n\n No dragging of arrows when bound, similar to elbow\n\nFix timeout not taking effect immediately\n\nBumop z-index for arrows when dragged\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nOnly transparent bindables allow binding fallthrough\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix lint\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix point click array creation interaction with fixed point binding\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nRestrict new behavior to arrows only\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nAllow binding inside images\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix already existing fixed binding retention\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nRefactor and implement fixed point binding for unfilled elements\n\nRestore drag\n\nRemoved point binding\n\nBinding code refactor\n\nAdded centered focus point\n\nBinding & focus point debug\n\nAdd invariants to check binding integrity in elements\n\nBinding fixes\n\nSmall refactors\n\nCompletely rewritten binding\n\nInclude point updates after binding update\n\nFix point updates when endpoint dragged and opposite endpoint orbits\n\ncentered focus point only for new arrows\n\nMake z-index arrow reorder on bind\n\nTurn off inside binding mode after leaving a shape\n\nRemove invariants from debug\n\nfeat: expose `applyTo` options, don't commit empty text element (#9744)\n\n* Expose applyTo options, skip re-draw for empty text\n\n* Don't commit empty text elements\n\ntest: added test file for distribute (#9754)\n\nz-index update\n\nBind mode on precise binding\n\nFix binding to inside element\n\nFix initial arrow not following cursor (white dot)\n\nFix elbow arrow\n\nFix z-index so it works on hover\n\nFix fixed angle orbiting\n\nMove point click arrow creation over to common strategy\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nAdd binding strategy for drag arrow creation\n\nFix elbow arrow\n\nFix point handles\n\nSnap to center\n\nFix transparent shape binding\n\nInternal arrow creation fix\n\nFix point binding\n\nFix selection bug\n\nFix new arrow focus point\n\nImages now always bind inside\n\nFlashing arrow creation on binding band\n\nAdd watchState debug method to window.h\n\nFix debug canvas crash\n\nRemove non-needed bind mode\n\nFix restore\n\nNo keyboard movement when bound\n\nAdd actionFinalize when arrow in edit mode\n\nAdd drag to the Stats panel when bound arrow is moved\n\nFurther simplify curve tracking\n\nAdd typing to action register()\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix point at finalize\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix type errors\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nNew arrow binding rules\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix cyclical dep\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix jiggly arrows\n\nFix jiggly arrow x2\n\nLong inside-other binding\n\nClick-click binding\n\nFix arrows\n\nPerformance\n\n[PERF] Replace in-place Jacobian derivation with analytical version\n\nDifferent approach to inside binding\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFixes\n\nFix inconsistent arrow start jump out\n\nChange how images are bound to on new arrow creation\n\nLower timeout\n\nSmall insurance fix\n\nFix curve test\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nNo center focus point\n\n90% inside center binding\n\nFixing tests\n\nfix: Elbow arrow fixes\n\nfix: More arrow fixes\n\nDo not trigger arrow binding for linear elements\n\nfix: Linear elements\n\nfix: Refactor actionFinalize for linear\n\nBinding tests updated\n\nfix: Jump when cursor not moved\n\nfix: history tests\n\nFix history snapshot\n\nFix undo issue\n\nfix(eraser): Remove binding from the other element\n\nfix(tests): Update tests\n\nchore: Attempt filtering new set state\n\nFix excessive history recording\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix all tests\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nfix(transform): Fix group resize and rotate\n\nfix(binding): Harmonize binding param usage\n\nfix: Center focus point\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nchore: Trigger build\n\nRemove binding gap\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nBinding highlight refactor\n\nfix: Refactored timeout bind mode handling\n\nfix: Center when orbiting\n\nfeat: Color change on highlight\n\nFix orbit binding highlight\n\nfix: hiding arrow\n\nFix arrow binding\n\nFix arrow drag selection logic\n\nBinding highlight is now hot pink\n\nChange inside binding logic for start point\n\nRender focus point in debug mode\n\nFix snap to center\n\nFix actionFinalize for new arrow creation\n\nfix: snapToCenter()\n\n80% by length\n\nfix: attempt at fixing the dancing arrows\n\nfeat: No center snap when start is not bound\n\nFix centering for existing arrows\n\ntweak binding highlight color\n\nchange `appState.suggestedBindings` -> `suggestedBinding` & remove unused code\n\nRefactor delayed bind mode change\n\nBinding highlight rotation support + image support\n\nfix(highlight): Overdraw fixes\n\nfeat: Do not allow drag bound arrow closer to the shape than dragging distance\n\nfeat: Stroke width adaptive fixed binding distance\n\nchore: More point dragging centralization\n\nNew element behavior\n\nRefactor dragging\n\nFix incorrect highlight sizing\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix delayed bind mode for multiElement arrows\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix multi-point\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFix elbow arrows\n\nSimplify state\n\nSmall positional fixes\n\nFix jiggly arrows\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nFixes for arrow dragging\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\nElbow arrow fixes\n\nHighlight fixes\n\nFix elbow arrow binding\n\nFrame highlight\n\nFix elbow mid-point binding\n\nFix binding suggestion for disabled binding state\n\nImplement Alt\n\nRemove debug\n\n* CHange new arrow creation\n\n* fix: allow inside binding via timeout if arrow has no startBinding\n\n* fix: Delete invariant violation with arrows\n\n* fix: Deleted arrow causes problems\n\n* fix: Dragging issues\n\n* fix: Dragging fix 2\n\n* fix: Disable drag drag when arrow is bound\n\n* fix: Multipoint arrow opposite point movement\n\n* fix: Ctrl+Alt precedence\n\n* feat: Alt inside start binding mode change\n\n* Fix multipoint arrow orbit\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Arrow start inside binding switch\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: New arrow never binds inside\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* chore: Small refactor\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Multi-point arrows and linears\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Lint\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* feat: Nested shapes handling\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Overlap behavior\n\n* Alt unbind fix\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Existing arrow nested bindable\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Binding suggestions\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Circular dep\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: snapshots\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Alt immediate update\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* chore: Laxing on invariants\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: New highlight overdraws arrow\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Image binding rule changed\n\n* Trigger Rebuild\n\n* fix:Highlight flicker\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Fully nested shapes\n\n* fix: Tune nested shape binding\n\n* fix: Size-based orbit jump-in\n\n* fix: Binding highlight stroke on sharp bindables\n\n* fix: Nested shape binding\n\n* fix: history\n\n* fix:More precise element nesting check\n\n* feat:Add tolerance to shape nesting detection\n\n* fix: Reverse\n\n* fix:Change center binding to circular\n\n* ignore invisible elements when binding\n\n* feat: Center point with more precise highlight outlines\n\n* fix:Arrow tool hover stuck highlight\n\n* fix:More stroke width for highlight\n\n* POC: highlight center on hover\n\n* tweak binding highlight width\n\n* render highlight on the outside\n\n* fix: Locked elbow arrow creation\n\n* update hints\n\n* reduce timeout\n\n* handle overlap when both elements the same size\n\n* tweak highlight stroke width some more\n\n* fix:Add intersection padding\n\n* fix: New arrow start orbit when nested binds on the end\n\n* fix: Update history snapshot\n\n* feat: Allow inside binding for new arrows in nested cases\n\n* chore: Logic for measurement\n\n* fix: Locked tool + arrow\n\n* feat: Remove center binding\n\n* fix: Jump arrow inside it gets visially too short\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* chore:Basic interactive canvas animation re-render trigger for highlights\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* feat:Highlight animations\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix:Refactored and fixed highlight animation\n\n* fix:Poisoned arrow\n\n* fix Arrow edit mode selection\n\n* fix:Tool lock binding behavior restored\n\n* fix:Overlap inside binding\n\n* fix:Animated binding highlight\n\n* alt anims + increase timeout to 700\n\n* tweak animation some more + remove countdown\n\n* fix: False bind timeout indicator\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* feat: better file normalization (#10024)\n\n* feat: better file normalization\n\n* fix lint\n\n* fix png detection\n\n* optimize\n\n* fix type\n\n* fix: increase rejection delay for opening files with legacy api (#8961)\n\n* Increased input change interval to 1000 ms to fix IOS 18 file opening issue\n\n* increase more\n\n---------\n\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>\n\n* feat: library search (#9903)\n\n* feat(utils): add support for search input type in isWritableElement\n\n* feat(i18n): add search text\n\n* feat(cmdp+lib): add search functionality for command pallete and lib menu items\n\n* chore: fix formats, and whitespaces\n\n* fix: opt to optimal code changes\n\n* chore: fix for linting\n\n* focus input on mount\n\n* tweak placeholder\n\n* design and UX changes\n\n* tweak item hover/active/seletected states\n\n* unrelated: move publish button above delete/clear to keep it more stable\n\n* esc to clear search input / close sidebar\n\n* refactor command pallete library stuff\n\n* make library commands bigger\n\n---------\n\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>\n\n* fix: Allow already inside bound arrows to continue inside binding\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* feat: No angle lock over bindable elements\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* feat: Center binding on SHIFT key\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* Fix ghost start binding\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* FEAT: No binding to frame cutout\n\n* feat: Bind to frame when frame-bound object hidden part is approached\n\n* fix: revert preferred selection to box once you switch to `full` UI (#10160)\n\n* fix: mobile UI and other fixes (#10177)\n\n* remove legacy openMenu=shape state and unused actions\n\n* close menus/popups in applicable cases when opening a different one\n\n* split ui z-indexes to account prefer different overlap\n\n* make top canvas area clickable on mobile\n\n* make mobile main menu closable by clicking outside and reduce width\n\n* offset picker popups from viewport border on mobile\n\n* reduce items gap in mobile main menu\n\n* show top picks for canvas bg colors in all ui modes\n\n* fix menu separator visibility on mobile\n\n* fix command palette items not being filtered\n\n* fix: Increase transform handle offset (#10180)\n\n* fix: Increase transform handle offset\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Temporarily disable transform handles for linear elements on mobile and tablets\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Linear hidden resize\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* disable mobielOrTablet linear element bbox completely\n\n* fix: Test\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Lint\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n---------\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>\n\n* fix: context menu getting covered (#10199)\n\n* do not show z-index actions on mobile or tablet\n\n* fix: context menu getting covered\n\n* fix lint\n\n* fix style popup getting covered\n\n* put contextmenu z-index above sidebar\n\n---------\n\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>\n\n* feat: More prominent keyboard shortcuts in hints (#10057)\n\n* Initial\n\n* Memoize\n\n* Styling\n\n* Use double angle brackets for keyboard shortcuts\n\n* Use rem in gap\n\n* Use an existing function for substituting tags in a string\n\n* Revert styling\n\n* Avoid unique key warnings\n\n* Styling\n\n* getTransChildren -> nodesFromTextWithTags\n\n* Use height and padding instead of padding only\n\n* Initial new idea\n\n* WIP shortcut substitutions\n\n* Use simple regex for parsing shortcuts\n\n* Use single shortcut for combos\n\n* Use kbd instead of span\n\n* shortcutFromKeyString -> getTaggedShortcutKey\n\n* Bug fix\n\n* FlowChart -> Flowchart\n\n* memo is useless here\n\n* Trigger CI\n\n* Translate in getShortcutKey\n\n* More normalized shortcuts\n\n* improve shortcut normalization and replacement & support multi-key tagged shortcuts\n\n* fix regex\n\n* tweak css\n\n---------\n\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>\n\n* fix: small tweaks to shortcut hints (#10214)\n\n* fix: Test\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Bind mode\n\n* feat: Support special key shortcut highlight\n\n* fix: Lint\n\n* fix: Remove non-needed function\n\n* fix: Skip frame cutout for hover, but keep shape for binding\n\n* fix: Lint\n\n* fix: Restore removal of deleted elements on restore\n\n* fix: Inside-inside during drag\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Arrow vanishes when orbit binding to the same element\n\n* feat: Feature flag support\n\n* Simplified binding\n\n* fix: Diamond corner binding\n\n* feat: Binding highlight band re-added\n\n* feat: Settings menu\n\n* fix: Same shape binding\n\n* fix: set radix PropertiesPopover collision boundary (#10221)\n\n* Set collision boundary\n\n* Calculate collisionPadding dynamically based on container\n\n* Add appState offsetTop and offsetLeft to padding calculation.\n\nRefactor collisionPadding calculation to use app state offsets.\n\n* Update PropertiesPopover.tsx\n\n* popover positioning relative to container\n\n* fix: prevent wrap text in a container to only text that are not bound to a container (#10250)\n\n* fix: only enable wrap text in a container when at least one text element selected is unbound\n\n* Trigger Rebuild\n\n---------\n\nCo-authored-by: Mark Tolmacs <mark@lazycat.hu>\n\n* chore: Uncap the nodejs version requirement (#10238)\n\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>\n\n* refactor: single source of truths with editor interface (#10178)\n\n* refactor device to editor interface and derive styles panel\n\n* allow host app to control form factor and ui mode\n\n* add editor interface event listener\n\n* put new props inside UIOptions\n\n* refactor: move related apis into one file\n\n* expose getFormFactor\n\n* privatize the setting of desktop mode and fix snapshots\n\n* refactor and fix test\n\n* remove unimplemented code\n\n* export getFormFactor()\n\n* replace `getFormFactor` with `getEditorInterface`\n\n* remove dead & useless\n\n* comment\n\n* fix ts\n\n---------\n\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>\n\n* chore: Update translations from Crowdin (#7429)\n\n* New translations en.json (Punjabi)\n\n* New translations en.json (Polish)\n\n* New translations en.json (Russian)\n\n* New translations en.json (Turkish)\n\n* New translations en.json (Ukrainian)\n\n* New translations en.json (Chinese Traditional)\n\n* New translations en.json (Vietnamese)\n\n* New translations en.json (Galician)\n\n* New translations en.json (Portuguese, Brazilian)\n\n* New translations en.json (Persian)\n\n* New translations en.json (Khmer)\n\n* New translations en.json (Tamil)\n\n* New translations en.json (Bengali)\n\n* New translations en.json (Marathi)\n\n* New translations en.json (Thai)\n\n* New translations en.json (Norwegian Nynorsk)\n\n* New translations en.json (Kazakh)\n\n* New translations en.json (Latvian)\n\n* New translations en.json (Azerbaijani)\n\n* New translations en.json (Hindi)\n\n* New translations en.json (Burmese)\n\n* New translations en.json (Chinese Traditional, Hong Kong)\n\n* New translations en.json (Sinhala)\n\n* New translations en.json (Uzbek)\n\n* New translations en.json (Norwegian Bokmal)\n\n* New translations en.json (Occitan)\n\n* New translations en.json (German, Switzerland)\n\n* New translations en.json (Bengali, India)\n\n* New translations en.json (Kabyle)\n\n* New translations en.json (Karakalpak)\n\n* New translations en.json (Portuguese)\n\n* New translations en.json (Russian)\n\n* New translations en.json (Marathi)\n\n* New translations en.json (Hindi)\n\n* New translations en.json (German)\n\n* New translations en.json (Chinese Simplified)\n\n* New translations en.json (Polish)\n\n* New translations en.json (Romanian)\n\n* New translations en.json (Korean)\n\n* New translations en.json (Chinese Traditional)\n\n* New translations en.json (Hebrew)\n\n* New translations en.json (Hebrew)\n\n* New translations en.json (Slovak)\n\n* New translations en.json (Slovak)\n\n* New translations en.json (Hungarian)\n\n* New translations en.json (Hungarian)\n\n* New translations en.json (Slovak)\n\n* New translations en.json (Hebrew)\n\n* New translations en.json (Hungarian)\n\n* New translations en.json (Korean)\n\n* New translations en.json (Chinese Traditional)\n\n* New translations en.json (Romanian)\n\n* New translations en.json (French)\n\n* New translations en.json (Spanish)\n\n* New translations en.json (Arabic)\n\n* New translations en.json (Bulgarian)\n\n* New translations en.json (Catalan)\n\n* New translations en.json (Czech)\n\n* New translations en.json (Danish)\n\n* New translations en.json (German)\n\n* New translations en.json (Greek)\n\n* New translations en.json (Basque)\n\n* New translations en.json (Finnish)\n\n* New translations en.json (Italian)\n\n* New translations en.json (Japanese)\n\n* New translations en.json (Kurdish)\n\n* New translations en.json (Lithuanian)\n\n* New translations en.json (Dutch)\n\n* New translations en.json (Punjabi)\n\n* New translations en.json (Polish)\n\n* New translations en.json (Portuguese)\n\n* New translations en.json (Russian)\n\n* New translations en.json (Slovenian)\n\n* New translations en.json (Swedish)\n\n* New translations en.json (Turkish)\n\n* New translations en.json (Ukrainian)\n\n* New translations en.json (Chinese Simplified)\n\n* New translations en.json (Vietnamese)\n\n* New translations en.json (Galician)\n\n* New translations en.json (Portuguese, Brazilian)\n\n* New translations en.json (Indonesian)\n\n* New translations en.json (Persian)\n\n* New translations en.json (Khmer)\n\n* New translations en.json (Tamil)\n\n* New translations en.json (Bengali)\n\n* New translations en.json (Marathi)\n\n* New translations en.json (Thai)\n\n* New translations en.json (Norwegian Nynorsk)\n\n* New translations en.json (Kazakh)\n\n* New translations en.json (Latvian)\n\n* New translations en.json (Azerbaijani)\n\n* New translations en.json (Hindi)\n\n* New translations en.json (Burmese)\n\n* New translations en.json (Chinese Traditional, Hong Kong)\n\n* New translations en.json (Sinhala)\n\n* New translations en.json (Uzbek)\n\n* New translations en.json (Norwegian Bokmal)\n\n* New translations en.json (Occitan)\n\n* New translations en.json (German, Switzerland)\n\n* New translations en.json (Bengali, India)\n\n* New translations en.json (Kabyle)\n\n* New translations en.json (Karakalpak)\n\n* New translations en.json (Romanian)\n\n* New translations en.json (German)\n\n* New translations en.json (Slovenian)\n\n* New translations en.json (Chinese Simplified)\n\n* New translations en.json (Spanish)\n\n* New translations en.json (Russian)\n\n* New translations en.json (Chinese Traditional)\n\n* New translations en.json (Turkish)\n\n* New translations en.json (Slovak)\n\n* New translations en.json (Slovak)\n\n* New translations en.json (Hebrew)\n\n* New translations en.json (Hungarian)\n\n* New translations en.json (Korean)\n\n* New translations en.json (Chinese Traditional)\n\n* New translations en.json (Romanian)\n\n* New translations en.json (French)\n\n* New translations en.json (Spanish)\n\n* New translations en.json (Arabic)\n\n* New translations en.json (Bulgarian)\n\n* New translations en.json (Catalan)\n\n* New translations en.json (Czech)\n\n* New translations en.json (Danish)\n\n* New translations en.json (German)\n\n* New translations en.json (Greek)\n\n* New translations en.json (Basque)\n\n* New translations en.json (Finnish)\n\n* New translations en.json (Italian)\n\n* New translations en.json (Japanese)\n\n* New translations en.json (Kurdish)\n\n* New translations en.json (Lithuanian)\n\n* New translations en.json (Dutch)\n\n* New translations en.json (Punjabi)\n\n* New translations en.json (Polish)\n\n* New translations en.json (Portuguese)\n\n* New translations en.json (Russian)\n\n* New translations en.json (Slovenian)\n\n* New translations en.json (Swedish)\n\n* New translations en.json (Turkish)\n\n* New translations en.json (Ukrainian)\n\n* New translations en.json (Chinese Simplified)\n\n* New translations en.json (Vietnamese)\n\n* New translations en.json (Galician)\n\n* New translations en.json (Portuguese, Brazilian)\n\n* New translations en.json (Indonesian)\n\n* New translations en.json (Persian)\n\n* New translations en.json (Khmer)\n\n* New translations en.json (Tamil)\n\n* New translations en.json (Bengali)\n\n* New translations en.json (Marathi)\n\n* New translations en.json (Thai)\n\n* New translations en.json (Norwegian Nynorsk)\n\n* New translations en.json (Kazakh)\n\n* New translations en.json (Latvian)\n\n* New translations en.json (Azerbaijani)\n\n* New translations en.json (Hindi)\n\n* New translations en.json (Burmese)\n\n* New translations en.json (Chinese Traditional, Hong Kong)\n\n* New translations en.json (Sinhala)\n\n* New translations en.json (Uzbek)\n\n* New translations en.json (Norwegian Bokmal)\n\n* New translations en.json (Occitan)\n\n* New translations en.json (German, Switzerland)\n\n* New translations en.json (Bengali, India)\n\n* New translations en.json (Kabyle)\n\n* New translations en.json (Karakalpak)\n\n* New translations en.json (German)\n\n* New translations en.json (Russian)\n\n* New translations en.json (Romanian)\n\n* New translations en.json (Spanish)\n\n* New translations en.json (Chinese Simplified)\n\n* New translations en.json (Marathi)\n\n* New translations en.json (Hindi)\n\n* New translations en.json (Slovak)\n\n* New translations en.json (German)\n\n* New translations en.json (Portuguese)\n\n* New translations en.json (Romanian)\n\n* New translations en.json (French)\n\n* New translations en.json (Spanish)\n\n* New translations en.json (Arabic)\n\n* New translations en.json (Bulgarian)\n\n* New translations en.json (Catalan)\n\n* New translations en.json (Czech)\n\n* New translations en.json (Danish)\n\n* New translations en.json (German)\n\n* New translations en.json (Greek)\n\n* New translations en.json (Basque)\n\n* New translations en.json (Finnish)\n\n* New translations en.json (Hebrew)\n\n* New translations en.json (Hungarian)\n\n* New translations en.json (Italian)\n\n* New translations en.json (Japanese)\n\n* New translations en.json (Korean)\n\n* New translations en.json (Kurdish)\n\n* New translations en.json (Lithuanian)\n\n* New translations en.json (Dutch)\n\n* New translations en.json (Punjabi)\n\n* New translations en.json (Polish)\n\n* New translations en.json (Portuguese)\n\n* New translations en.json (Russian)\n\n* New translations en.json (Slovak)\n\n* New translations en.json (Slovenian)\n\n* New translations en.json (Swedish)\n\n* New translations en.json (Turkish)\n\n* New translations en.json (Ukrainian)\n\n* New translations en.json (Chinese Simplified)\n\n* New translations en.json (Chinese Traditional)\n\n* New translations en.json (Vietnamese)\n\n* New translations en.json (Galician)\n\n* New translations en.json (Portuguese, Brazilian)\n\n* New translations en.json (Indonesian)\n\n* New translations en.json (Persian)\n\n* New translations en.json (Khmer)\n\n* New translations en.json (Tamil)\n\n* New translations en.json (Bengali)\n\n* New translations en.json (Marathi)\n\n* New translations en.json (Thai)\n\n* New translations en.json (Norwegian Nynorsk)\n\n* New translations en.json (Kazakh)\n\n* New translations en.json (Latvian)\n\n* New translations en.json (Azerbaijani)\n\n* New translations en.json (Hindi)\n\n* New translations en.json (Burmese)\n\n* New translations en.json (Chinese Traditional, Hong Kong)\n\n* New translations en.json (Sinhala)\n\n* New translations en.json (Uzbek)\n\n* New translations en.json (Norwegian Bokmal)\n\n* New translations en.json (Occitan)\n\n* New translations en.json (German, Switzerland)\n\n* New translations en.json (Bengali, India)\n\n* New translations en.json (Kabyle)\n\n* New translations en.json (Karakalpak)\n\n* Auto commit: Calculate translation coverage\n\n* New translations en.json (Chinese Simplified)\n\n* Auto commit: Calculate translation coverage\n\n* New translations en.json (Romanian)\n\n* Auto commit: Calculate translation coverage\n\n* New translations en.json (Romanian)\n\n* Auto commit: Calculate translation coverage\n\n* New translations en.json (French)\n\n* Auto commit: Calculate translation coverage\n\n* New translations en.json (Polish)\n\n* Auto commit: Calculate translation coverage\n\n* New translations en.json (Polish)\n\n* Auto commit: Calculate translation coverage\n\n* New translations en.json (Turkish)\n\n* Auto commit: Calculate translation coverage\n\n* New translations en.json (Turkish)\n\n---------\n\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>\n\n* fix: mobile view ui issues (#10284)\n\n* hide zen mode when formFactor = phone\n\n* tool bar fixes: icon and width\n\n* view mode\n\n* fix lint\n\n* add exit-view-mode button\n\n---------\n\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>\n\n* chore: Update snaps\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* feat: Blue highlight\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* feat: Diagonal binding point\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* chore: Remove settings\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* feat: Jump other binding\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Hovered arrow mode highlight\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* feat: Alt does not snap\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* chore: Check debug\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Alt precise positioning\n\n* fix: Jump out to orbit for new arrows when dragged outside\n\n* fix: New arrow preserved projection\n\n* chore: Remove debug\n\n* chore: Introduce different debug color for orbit and other binding modes\n\n* fix: Restore arrow start point when self binding\n\n* fix: Turn of start jump-out\n\n* fix: Tests\n\n* fix: Select the first possible altBindPoint\n\n* fix: Random projection\n\n* fix: Use last point for existing arrows\n\n* fix: Preserve alternate orbit focus point during drag\n\n* fix: Lint\n\n* fix: Update tests\n\n* fix: Elbow arrow direction at binding\n\n* binding gap and distance and binding highlight tweaks\n\n* chore: Naming refactors\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Tests\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Alt-duplication copied elements placement (#10152)\n\n* feat: Animation support (#10042)\n\n* fix: banner url (#10315)\n\n* feat: Animation support (#10042)\n\n* fix: Merge discrepancy\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* chore: Remove non-needed code\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* Trigger build\n\n* chore: Remove hint for V1\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* shorten focus point diagonal helpers to fix corner binding cases\n\n* fix: Tests\n\n* fix: Multi-point arrow closeness fallback\n\n* fix: Finalize multipoint arrow on binding area click\n\n* fix: Finalize arrow now truly finalzes\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Point click arrow creation jumping to orbit\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Alt+drag movement block\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* fix: Tests\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\n\n* Trigger build\n\n* feat: hide point highlight when dragging\n\n* feat: hide bbox when dragging points\n\n* revert binding gap increase for elbow arrows\n\n* reset selectionLinearElement on tool change\n\n* chore: Remove debug\n\n* feat: Better restore for bindings\n\n* use elementsMap instead of array when passing to restoreElement\n\n* fix: Arrow angle reset\n\n* fix: Arrow angle\n\n* Arrow angle support\n\n* fix trashing cached canvases in `LinearElementEditor.getElementAbsoluteCoords`\n\n---------\n\nSigned-off-by: Mark Tolmacs <mark@lazycat.hu>\nCo-authored-by: dwelle <5153846+dwelle@users.noreply.github.com>",
			"user": "mtolmacs",
			"timestamp": "2025-11-25T14:46:02Z",
			"author": {
				"name": "Márk Tolmács",
				"email": "mark@lazycat.hu",
				"username": "mtolmacs"
			},
			"files": {
				"added": [],
				"modified": [
					"excalidraw-app/components/DebugCanvas.tsx",
					"excalidraw-app/data/LocalData.ts",
					"excalidraw-app/data/localStorage.ts",
					"excalidraw-app/sentry.ts",
					"packages/common/src/constants.ts",
					"packages/common/src/utils.ts",
					"packages/common/src/visualdebug.ts",
					"packages/element/src/binding.ts",
					"packages/element/src/bounds.ts",
					"packages/element/src/collision.ts",
					"packages/element/src/dragElements.ts",
					"packages/element/src/elbowArrow.ts",
					"packages/element/src/flowchart.ts",
					"packages/element/src/index.ts",
					"packages/element/src/linearElementEditor.ts",
					"packages/element/src/mutateElement.ts",
					"packages/element/src/newElement.ts",
					"packages/element/src/renderElement.ts",
					"packages/element/src/resizeElements.ts",
					"packages/element/src/transformHandles.ts",
					"packages/element/src/typeChecks.ts",
					"packages/element/src/types.ts",
					"packages/element/src/utils.ts",
					"packages/element/src/zindex.ts",
					"packages/element/tests/binding.test.tsx",
					"packages/element/tests/bounds.test.ts",
					"packages/element/tests/duplicate.test.tsx",
					"packages/element/tests/elbowArrow.test.tsx",
					"packages/element/tests/linearElementEditor.test.tsx",
					"packages/element/tests/resize.test.tsx",
					"packages/excalidraw/actions/actionCanvas.tsx",
					"packages/excalidraw/actions/actionClipboard.tsx",
					"packages/excalidraw/actions/actionDeleteSelected.tsx",
					"packages/excalidraw/actions/actionExport.tsx",
					"packages/excalidraw/actions/actionFinalize.tsx",
					"packages/excalidraw/actions/actionFlip.test.tsx",
					"packages/excalidraw/actions/actionFlip.ts",
					"packages/excalidraw/actions/actionNavigate.tsx",
					"packages/excalidraw/actions/actionProperties.tsx",
					"packages/excalidraw/actions/register.ts",
					"packages/excalidraw/actions/types.ts",
					"packages/excalidraw/appState.ts",
					"packages/excalidraw/components/App.tsx",
					"packages/excalidraw/components/CommandPalette/CommandPalette.tsx",
					"packages/excalidraw/components/CommandPalette/types.ts",
					"packages/excalidraw/components/ConvertElementTypePopup.tsx",
					"packages/excalidraw/components/LayerUI.tsx",
					"packages/excalidraw/components/Stats/Angle.tsx",
					"packages/excalidraw/components/Stats/MultiDimension.tsx",
					"packages/excalidraw/components/Stats/MultiPosition.tsx",
					"packages/excalidraw/components/Stats/Position.tsx",
					"packages/excalidraw/components/Stats/index.tsx",
					"packages/excalidraw/components/Stats/stats.test.tsx",
					"packages/excalidraw/components/Stats/utils.ts",
					"packages/excalidraw/components/canvases/InteractiveCanvas.tsx",
					"packages/excalidraw/components/canvases/StaticCanvas.tsx",
					"packages/excalidraw/data/__snapshots__/transform.test.ts.snap",
					"packages/excalidraw/data/blob.ts",
					"packages/excalidraw/data/json.ts",
					"packages/excalidraw/data/restore.ts",
					"packages/excalidraw/data/transform.test.ts",
					"packages/excalidraw/data/transform.ts",
					"packages/excalidraw/global.d.ts",
					"packages/excalidraw/locales/en.json",
					"packages/excalidraw/package.json",
					"packages/excalidraw/renderer/helpers.ts",
					"packages/excalidraw/renderer/interactiveScene.ts",
					"packages/excalidraw/scene/types.ts",
					"packages/excalidraw/tests/__snapshots__/contextmenu.test.tsx.snap",
					"packages/excalidraw/tests/__snapshots__/dragCreate.test.tsx.snap",
					"packages/excalidraw/tests/__snapshots__/history.test.tsx.snap",
					"packages/excalidraw/tests/__snapshots__/move.test.tsx.snap",
					"packages/excalidraw/tests/__snapshots__/multiPointCreate.test.tsx.snap",
					"packages/excalidraw/tests/__snapshots__/regressionTests.test.tsx.snap",
					"packages/excalidraw/tests/__snapshots__/selection.test.tsx.snap",
					"packages/excalidraw/tests/data/__snapshots__/restore.test.ts.snap",
					"packages/excalidraw/tests/dragCreate.test.tsx",
					"packages/excalidraw/tests/history.test.tsx",
					"packages/excalidraw/tests/lasso.test.tsx",
					"packages/excalidraw/tests/library.test.tsx",
					"packages/excalidraw/tests/move.test.tsx",
					"packages/excalidraw/tests/multiPointCreate.test.tsx",
					"packages/excalidraw/tests/regressionTests.test.tsx",
					"packages/excalidraw/tests/rotate.test.tsx",
					"packages/excalidraw/tests/selection.test.tsx",
					"packages/excalidraw/types.ts",
					"packages/utils/src/test-utils.ts",
					"packages/utils/tests/__snapshots__/export.test.ts.snap"
				],
				"removed": []
			},
			"diff": "diff --git a/excalidraw-app/components/DebugCanvas.tsx b/excalidraw-app/components/DebugCanvas.tsx\nindex 71b0133076a8..9df430376bae 100644\n--- a/excalidraw-app/components/DebugCanvas.tsx\n+++ b/excalidraw-app/components/DebugCanvas.tsx\n@@ -15,7 +15,6 @@ import {\n   getGlobalFixedPointForBindableElement,\n   isArrowElement,\n   isBindableElement,\n-  isFixedPointBinding,\n } from \"@excalidraw/element\";\n \n import {\n@@ -35,7 +34,6 @@ import type {\n   ExcalidrawBindableElement,\n   FixedPointBinding,\n   OrderedExcalidrawElement,\n-  PointBinding,\n } from \"@excalidraw/element/types\";\n \n import { STORAGE_KEYS } from \"../app_constants\";\n@@ -91,48 +89,46 @@ const renderOrigin = (context: CanvasRenderingContext2D, zoom: number) => {\n \n const _renderBinding = (\n   context: CanvasRenderingContext2D,\n-  binding: FixedPointBinding | PointBinding,\n+  binding: FixedPointBinding,\n   elementsMap: ElementsMap,\n   zoom: number,\n   width: number,\n   height: number,\n   color: string,\n ) => {\n-  if (isFixedPointBinding(binding)) {\n-    if (!binding.fixedPoint) {\n-      console.warn(\"Binding must have a fixedPoint\");\n-      return;\n-    }\n+  if (!binding.fixedPoint) {\n+    console.warn(\"Binding must have a fixedPoint\");\n+    return;\n+  }\n \n-    const bindable = elementsMap.get(\n-      binding.elementId,\n-    ) as ExcalidrawBindableElement;\n-    const [x, y] = getGlobalFixedPointForBindableElement(\n-      binding.fixedPoint,\n-      bindable,\n-      elementsMap,\n-    );\n+  const bindable = elementsMap.get(\n+    binding.elementId,\n+  ) as ExcalidrawBindableElement;\n+  const [x, y] = getGlobalFixedPointForBindableElement(\n+    binding.fixedPoint,\n+    bindable,\n+    elementsMap,\n+  );\n \n-    context.save();\n-    context.strokeStyle = color;\n-    context.lineWidth = 1;\n-    context.beginPath();\n-    context.moveTo(x * zoom, y * zoom);\n-    context.bezierCurveTo(\n-      x * zoom - width,\n-      y * zoom - height,\n-      x * zoom - width,\n-      y * zoom + height,\n-      x * zoom,\n-      y * zoom,\n-    );\n-    context.stroke();\n-    context.restore();\n-  }\n+  context.save();\n+  context.strokeStyle = color;\n+  context.lineWidth = 1;\n+  context.beginPath();\n+  context.moveTo(x * zoom, y * zoom);\n+  context.bezierCurveTo(\n+    x * zoom - width,\n+    y * zoom - height,\n+    x * zoom - width,\n+    y * zoom + height,\n+    x * zoom,\n+    y * zoom,\n+  );\n+  context.stroke();\n+  context.restore();\n };\n \n const _renderBindableBinding = (\n-  binding: FixedPointBinding | PointBinding,\n+  binding: FixedPointBinding,\n   context: CanvasRenderingContext2D,\n   elementsMap: ElementsMap,\n   zoom: number,\n@@ -140,37 +136,35 @@ const _renderBindableBinding = (\n   height: number,\n   color: string,\n ) => {\n-  if (isFixedPointBinding(binding)) {\n-    const bindable = elementsMap.get(\n-      binding.elementId,\n-    ) as ExcalidrawBindableElement;\n-    if (!binding.fixedPoint) {\n-      console.warn(\"Binding must have a fixedPoint\");\n-      return;\n-    }\n+  const bindable = elementsMap.get(\n+    binding.elementId,\n+  ) as ExcalidrawBindableElement;\n+  if (!binding.fixedPoint) {\n+    console.warn(\"Binding must have a fixedPoint\");\n+    return;\n+  }\n \n-    const [x, y] = getGlobalFixedPointForBindableElement(\n-      binding.fixedPoint,\n-      bindable,\n-      elementsMap,\n-    );\n+  const [x, y] = getGlobalFixedPointForBindableElement(\n+    binding.fixedPoint,\n+    bindable,\n+    elementsMap,\n+  );\n \n-    context.save();\n-    context.strokeStyle = color;\n-    context.lineWidth = 1;\n-    context.beginPath();\n-    context.moveTo(x * zoom, y * zoom);\n-    context.bezierCurveTo(\n-      x * zoom + width,\n-      y * zoom + height,\n-      x * zoom + width,\n-      y * zoom - height,\n-      x * zoom,\n-      y * zoom,\n-    );\n-    context.stroke();\n-    context.restore();\n-  }\n+  context.save();\n+  context.strokeStyle = color;\n+  context.lineWidth = 1;\n+  context.beginPath();\n+  context.moveTo(x * zoom, y * zoom);\n+  context.bezierCurveTo(\n+    x * zoom + width,\n+    y * zoom + height,\n+    x * zoom + width,\n+    y * zoom - height,\n+    x * zoom,\n+    y * zoom,\n+  );\n+  context.stroke();\n+  context.restore();\n };\n \n const renderBindings = (\n@@ -197,12 +191,12 @@ const renderBindings = (\n \n         _renderBinding(\n           context,\n-          element.startBinding as FixedPointBinding,\n+          element.startBinding,\n           elementsMap,\n           zoom,\n           dim,\n           dim,\n-          \"red\",\n+          element.startBinding?.mode === \"orbit\" ? \"red\" : \"black\",\n         );\n       }\n \n@@ -221,7 +215,7 @@ const renderBindings = (\n           zoom,\n           dim,\n           dim,\n-          \"red\",\n+          element.endBinding?.mode === \"orbit\" ? \"red\" : \"black\",\n         );\n       }\n     }\ndiff --git a/excalidraw-app/data/LocalData.ts b/excalidraw-app/data/LocalData.ts\nindex a2a930a1ace0..13cdf09ac417 100644\n--- a/excalidraw-app/data/LocalData.ts\n+++ b/excalidraw-app/data/LocalData.ts\n@@ -16,7 +16,6 @@ import {\n   DEFAULT_SIDEBAR,\n   debounce,\n } from \"@excalidraw/common\";\n-import { clearElementsForLocalStorage } from \"@excalidraw/element\";\n import {\n   createStore,\n   entries,\n@@ -28,6 +27,7 @@ import {\n } from \"idb-keyval\";\n \n import { appJotaiStore, atom } from \"excalidraw-app/app-jotai\";\n+import { getNonDeletedElements } from \"@excalidraw/element\";\n \n import type { LibraryPersistedData } from \"@excalidraw/excalidraw/data/library\";\n import type { ImportedDataState } from \"@excalidraw/excalidraw/data/types\";\n@@ -88,7 +88,7 @@ const saveDataStateToLocalStorage = (\n \n     localStorage.setItem(\n       STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS,\n-      JSON.stringify(clearElementsForLocalStorage(elements)),\n+      JSON.stringify(getNonDeletedElements(elements)),\n     );\n     localStorage.setItem(\n       STORAGE_KEYS.LOCAL_STORAGE_APP_STATE,\ndiff --git a/excalidraw-app/data/localStorage.ts b/excalidraw-app/data/localStorage.ts\nindex bc0df4a67838..28c166cd749c 100644\n--- a/excalidraw-app/data/localStorage.ts\n+++ b/excalidraw-app/data/localStorage.ts\n@@ -2,7 +2,6 @@ import {\n   clearAppStateForLocalStorage,\n   getDefaultAppState,\n } from \"@excalidraw/excalidraw/appState\";\n-import { clearElementsForLocalStorage } from \"@excalidraw/element\";\n \n import type { ExcalidrawElement } from \"@excalidraw/element/types\";\n import type { AppState } from \"@excalidraw/excalidraw/types\";\n@@ -50,7 +49,7 @@ export const importFromLocalStorage = () => {\n   let elements: ExcalidrawElement[] = [];\n   if (savedElements) {\n     try {\n-      elements = clearElementsForLocalStorage(JSON.parse(savedElements));\n+      elements = JSON.parse(savedElements);\n     } catch (error: any) {\n       console.error(error);\n       // Do nothing because elements array is already empty\ndiff --git a/excalidraw-app/sentry.ts b/excalidraw-app/sentry.ts\nindex 30b84f3f6968..58e34bba53d9 100644\n--- a/excalidraw-app/sentry.ts\n+++ b/excalidraw-app/sentry.ts\n@@ -1,3 +1,4 @@\n+import { getFeatureFlag } from \"@excalidraw/common\";\n import * as Sentry from \"@sentry/browser\";\n import callsites from \"callsites\";\n \n@@ -33,6 +34,7 @@ Sentry.init({\n     Sentry.captureConsoleIntegration({\n       levels: [\"error\"],\n     }),\n+    Sentry.featureFlagsIntegration(),\n   ],\n   beforeSend(event) {\n     if (event.request?.url) {\n@@ -79,3 +81,14 @@ Sentry.init({\n     return event;\n   },\n });\n+\n+const flagsIntegration =\n+  Sentry.getClient()?.getIntegrationByName<Sentry.FeatureFlagsIntegration>(\n+    \"FeatureFlags\",\n+  );\n+if (flagsIntegration) {\n+  flagsIntegration.addFeatureFlag(\n+    \"COMPLEX_BINDINGS\",\n+    getFeatureFlag(\"COMPLEX_BINDINGS\"),\n+  );\n+}\ndiff --git a/packages/common/src/constants.ts b/packages/common/src/constants.ts\nindex a003cc1dd689..efacd4075f88 100644\n--- a/packages/common/src/constants.ts\n+++ b/packages/common/src/constants.ts\n@@ -499,6 +499,8 @@ export const LINE_POLYGON_POINT_MERGE_DISTANCE = 20;\n \n export const DOUBLE_TAP_POSITION_THRESHOLD = 35;\n \n+export const BIND_MODE_TIMEOUT = 700; // ms\n+\n // glass background for mobile action buttons\n export const MOBILE_ACTION_BUTTON_BG = {\n   background: \"var(--mobile-action-button-bg)\",\ndiff --git a/packages/common/src/utils.ts b/packages/common/src/utils.ts\nindex 69e854b0b01d..356f951521db 100644\n--- a/packages/common/src/utils.ts\n+++ b/packages/common/src/utils.ts\n@@ -1,10 +1,6 @@\n import { average } from \"@excalidraw/math\";\n \n-import type {\n-  ExcalidrawBindableElement,\n-  FontFamilyValues,\n-  FontString,\n-} from \"@excalidraw/element/types\";\n+import type { FontFamilyValues, FontString } from \"@excalidraw/element/types\";\n \n import type {\n   ActiveTool,\n@@ -382,6 +378,10 @@ export const removeSelection = () => {\n \n export const distance = (x: number, y: number) => Math.abs(x - y);\n \n+export const isSelectionLikeTool = (type: ToolType | \"custom\") => {\n+  return type === \"selection\" || type === \"lasso\";\n+};\n+\n export const updateActiveTool = (\n   appState: Pick<AppState, \"activeTool\">,\n   data: ((\n@@ -558,9 +558,6 @@ export const isTransparent = (color: string) => {\n   );\n };\n \n-export const isBindingFallthroughEnabled = (el: ExcalidrawBindableElement) =>\n-  el.fillStyle !== \"solid\" || isTransparent(el.backgroundColor);\n-\n export type ResolvablePromise<T> = Promise<T> & {\n   resolve: [T] extends [undefined]\n     ? (value?: MaybePromise<Awaited<T>>) => void\n@@ -1270,3 +1267,47 @@ export const reduceToCommonValue = <T, R = T>(\n \n   return commonValue;\n };\n+\n+type FEATURE_FLAGS = {\n+  COMPLEX_BINDINGS: boolean;\n+};\n+\n+const FEATURE_FLAGS_STORAGE_KEY = \"excalidraw-feature-flags\";\n+const DEFAULT_FEATURE_FLAGS: FEATURE_FLAGS = {\n+  COMPLEX_BINDINGS: false,\n+};\n+let featureFlags: FEATURE_FLAGS | null = null;\n+\n+export const getFeatureFlag = <F extends keyof FEATURE_FLAGS>(\n+  flag: F,\n+): FEATURE_FLAGS[F] => {\n+  if (!featureFlags) {\n+    try {\n+      const serializedFlags = localStorage.getItem(FEATURE_FLAGS_STORAGE_KEY);\n+      if (serializedFlags) {\n+        const flags = JSON.parse(serializedFlags);\n+        featureFlags = flags ?? DEFAULT_FEATURE_FLAGS;\n+      }\n+    } catch {}\n+  }\n+\n+  return (featureFlags || DEFAULT_FEATURE_FLAGS)[flag];\n+};\n+\n+export const setFeatureFlag = <F extends keyof FEATURE_FLAGS>(\n+  flag: F,\n+  value: FEATURE_FLAGS[F],\n+) => {\n+  try {\n+    featureFlags = {\n+      ...(featureFlags || DEFAULT_FEATURE_FLAGS),\n+      [flag]: value,\n+    };\n+    localStorage.setItem(\n+      FEATURE_FLAGS_STORAGE_KEY,\n+      JSON.stringify(featureFlags),\n+    );\n+  } catch (e) {\n+    console.error(\"unable to set feature flag\", e);\n+  }\n+};\ndiff --git a/packages/common/src/visualdebug.ts b/packages/common/src/visualdebug.ts\nindex 961fa919f275..993612959e4d 100644\n--- a/packages/common/src/visualdebug.ts\n+++ b/packages/common/src/visualdebug.ts\n@@ -139,7 +139,7 @@ export const debugDrawPoints = (\n   }: {\n     x: number;\n     y: number;\n-    points: LocalPoint[];\n+    points: readonly LocalPoint[];\n   },\n   options?: any,\n ) => {\ndiff --git a/packages/element/src/binding.ts b/packages/element/src/binding.ts\nindex fa1355309bef..473b2ec7bed7 100644\n--- a/packages/element/src/binding.ts\n+++ b/packages/element/src/binding.ts\n@@ -1,32 +1,27 @@\n import {\n   KEYS,\n   arrayToMap,\n-  isBindingFallthroughEnabled,\n-  tupleToCoors,\n+  getFeatureFlag,\n   invariant,\n-  isDevEnv,\n-  isTestEnv,\n+  isTransparent,\n } from \"@excalidraw/common\";\n \n import {\n+  PRECISION,\n+  clamp,\n   lineSegment,\n+  pointDistance,\n+  pointDistanceSq,\n   pointFrom,\n+  pointFromVector,\n   pointRotateRads,\n-  type GlobalPoint,\n   vectorFromPoint,\n-  pointDistanceSq,\n-  clamp,\n-  pointDistance,\n-  pointFromVector,\n-  vectorScale,\n   vectorNormalize,\n-  vectorCross,\n-  pointsEqual,\n-  lineSegmentIntersectionPoints,\n-  PRECISION,\n+  vectorScale,\n+  type GlobalPoint,\n } from \"@excalidraw/math\";\n \n-import type { LocalPoint, Radians } from \"@excalidraw/math\";\n+import type { LineSegment, LocalPoint, Radians } from \"@excalidraw/math\";\n \n import type { AppState } from \"@excalidraw/excalidraw/types\";\n \n@@ -37,7 +32,13 @@ import {\n   getCenterForBounds,\n   getElementBounds,\n } from \"./bounds\";\n-import { intersectElementWithLineSegment } from \"./collision\";\n+import {\n+  getAllHoveredElementAtPoint,\n+  getHoveredElementForBinding,\n+  intersectElementWithLineSegment,\n+  isBindableElementInsideOtherBindable,\n+  isPointInElement,\n+} from \"./collision\";\n import { distanceToElement } from \"./distance\";\n import {\n   headingForPointFromElement,\n@@ -53,46 +54,84 @@ import {\n   isBindableElement,\n   isBoundToContainer,\n   isElbowArrow,\n-  isFixedPointBinding,\n-  isFrameLikeElement,\n-  isLinearElement,\n   isRectanguloidElement,\n   isTextElement,\n } from \"./typeChecks\";\n \n import { aabbForElement, elementCenterPoint } from \"./bounds\";\n import { updateElbowArrowPoints } from \"./elbowArrow\";\n+import { projectFixedPointOntoDiagonal } from \"./utils\";\n \n import type { Scene } from \"./Scene\";\n \n import type { Bounds } from \"./bounds\";\n import type { ElementUpdate } from \"./mutateElement\";\n import type {\n-  ExcalidrawBindableElement,\n-  ExcalidrawElement,\n-  NonDeleted,\n-  ExcalidrawLinearElement,\n-  PointBinding,\n-  NonDeletedExcalidrawElement,\n+  BindMode,\n   ElementsMap,\n-  NonDeletedSceneElementsMap,\n-  ExcalidrawTextElement,\n   ExcalidrawArrowElement,\n+  ExcalidrawBindableElement,\n   ExcalidrawElbowArrowElement,\n+  ExcalidrawElement,\n+  ExcalidrawTextElement,\n   FixedPoint,\n   FixedPointBinding,\n+  NonDeleted,\n+  NonDeletedExcalidrawElement,\n+  NonDeletedSceneElementsMap,\n+  Ordered,\n   PointsPositionUpdates,\n } from \"./types\";\n \n-export type SuggestedBinding =\n-  | NonDeleted<ExcalidrawBindableElement>\n-  | SuggestedPointBinding;\n+export type BindingStrategy =\n+  // Create a new binding with this mode\n+  | {\n+      mode: BindMode;\n+      element: NonDeleted<ExcalidrawBindableElement>;\n+      focusPoint: GlobalPoint;\n+    }\n+  // Break the binding\n+  | {\n+      mode: null;\n+      element?: undefined;\n+      focusPoint?: undefined;\n+    }\n+  // Keep the existing binding\n+  | {\n+      mode: undefined;\n+      element?: undefined;\n+      focusPoint?: undefined;\n+    };\n \n-export type SuggestedPointBinding = [\n-  NonDeleted<ExcalidrawLinearElement>,\n-  \"start\" | \"end\" | \"both\",\n-  NonDeleted<ExcalidrawBindableElement>,\n-];\n+/**\n+ * gaps exclude element strokeWidth\n+ *\n+ * IMPORTANT: currently must be > 0 (this also applies to the computed gap)\n+ */\n+export const BASE_BINDING_GAP = 10;\n+export const BASE_BINDING_GAP_ELBOW = 5;\n+\n+export const getBindingGap = (\n+  bindTarget: ExcalidrawBindableElement,\n+  opts: Pick<ExcalidrawArrowElement, \"elbowed\">,\n+): number => {\n+  return (\n+    (opts.elbowed ? BASE_BINDING_GAP_ELBOW : BASE_BINDING_GAP) +\n+    bindTarget.strokeWidth / 2\n+  );\n+};\n+\n+export const maxBindingDistance_simple = (zoom?: AppState[\"zoom\"]): number => {\n+  const BASE_BINDING_DISTANCE = Math.max(BASE_BINDING_GAP, 15);\n+  const zoomValue = zoom?.value && zoom.value < 1 ? zoom.value : 1;\n+  return clamp(\n+    // reducing zoom impact so that the diff between binding distance and\n+    // binding gap is kept to minimum when possible\n+    BASE_BINDING_DISTANCE / (zoomValue * 1.5),\n+    BASE_BINDING_DISTANCE,\n+    BASE_BINDING_DISTANCE * 2,\n+  );\n+};\n \n export const shouldEnableBindingForPointerEvent = (\n   event: React.PointerEvent<HTMLElement>,\n@@ -104,633 +143,875 @@ export const isBindingEnabled = (appState: AppState): boolean => {\n   return appState.isBindingEnabled;\n };\n \n-export const FIXED_BINDING_DISTANCE = 5;\n-export const BINDING_HIGHLIGHT_THICKNESS = 10;\n-\n-const getNonDeletedElements = (\n+export const bindOrUnbindBindingElement = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  draggingPoints: PointsPositionUpdates,\n   scene: Scene,\n-  ids: readonly ExcalidrawElement[\"id\"][],\n-): NonDeleted<ExcalidrawElement>[] => {\n-  const result: NonDeleted<ExcalidrawElement>[] = [];\n-  ids.forEach((id) => {\n-    const element = scene.getNonDeletedElement(id);\n-    if (element != null) {\n-      result.push(element);\n+  appState: AppState,\n+  opts?: {\n+    newArrow?: boolean;\n+    altKey?: boolean;\n+    initialBinding?: boolean;\n+  },\n+) => {\n+  const { start, end } = getBindingStrategyForDraggingBindingElementEndpoints(\n+    arrow,\n+    draggingPoints,\n+    scene.getNonDeletedElementsMap(),\n+    scene.getNonDeletedElements(),\n+    appState,\n+    {\n+      ...opts,\n+      finalize: true,\n+    },\n+  );\n+\n+  bindOrUnbindBindingElementEdge(arrow, start, \"start\", scene);\n+  bindOrUnbindBindingElementEdge(arrow, end, \"end\", scene);\n+  if (start.focusPoint || end.focusPoint) {\n+    // If the strategy dictates a focus point override, then\n+    // update the arrow points to point to the focus point.\n+    const updates: PointsPositionUpdates = new Map();\n+\n+    if (start.focusPoint) {\n+      updates.set(0, {\n+        point:\n+          updateBoundPoint(\n+            arrow,\n+            \"startBinding\",\n+            arrow.startBinding,\n+            start.element,\n+            scene.getNonDeletedElementsMap(),\n+          ) || arrow.points[0],\n+      });\n     }\n-  });\n-  return result;\n+\n+    if (end.focusPoint) {\n+      updates.set(arrow.points.length - 1, {\n+        point:\n+          updateBoundPoint(\n+            arrow,\n+            \"endBinding\",\n+            arrow.endBinding,\n+            end.element,\n+            scene.getNonDeletedElementsMap(),\n+          ) || arrow.points[arrow.points.length - 1],\n+      });\n+    }\n+\n+    LinearElementEditor.movePoints(arrow, scene, updates);\n+  }\n+\n+  return { start, end };\n };\n \n-export const bindOrUnbindLinearElement = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n-  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n+const bindOrUnbindBindingElementEdge = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  { mode, element, focusPoint }: BindingStrategy,\n+  startOrEnd: \"start\" | \"end\",\n   scene: Scene,\n ): void => {\n-  const elementsMap = scene.getNonDeletedElementsMap();\n-  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n-  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n-  bindOrUnbindLinearElementEdge(\n-    linearElement,\n-    startBindingElement,\n-    endBindingElement,\n-    \"start\",\n-    boundToElementIds,\n-    unboundFromElementIds,\n-    scene,\n-    elementsMap,\n+  if (mode === null) {\n+    // null means break the binding\n+    unbindBindingElement(arrow, startOrEnd, scene);\n+  } else if (mode !== undefined) {\n+    bindBindingElement(arrow, element, mode, startOrEnd, scene, focusPoint);\n+  }\n+};\n+\n+const bindingStrategyForElbowArrowEndpointDragging = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  draggingPoints: PointsPositionUpdates,\n+  elementsMap: NonDeletedSceneElementsMap,\n+  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n+  zoom?: AppState[\"zoom\"],\n+): {\n+  start: BindingStrategy;\n+  end: BindingStrategy;\n+} => {\n+  invariant(draggingPoints.size === 1, \"Bound elbow arrows cannot be moved\");\n+\n+  const update = draggingPoints.entries().next().value;\n+\n+  invariant(\n+    update,\n+    \"There should be a position update for dragging an elbow arrow endpoint\",\n   );\n-  bindOrUnbindLinearElementEdge(\n-    linearElement,\n-    endBindingElement,\n-    startBindingElement,\n-    \"end\",\n-    boundToElementIds,\n-    unboundFromElementIds,\n-    scene,\n+\n+  const [pointIdx, { point }] = update;\n+  const globalPoint = LinearElementEditor.getPointGlobalCoordinates(\n+    arrow,\n+    point,\n     elementsMap,\n   );\n-\n-  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n-    (id) => !boundToElementIds.has(id),\n+  const hit = getHoveredElementForBinding(\n+    globalPoint,\n+    elements,\n+    elementsMap,\n+    (element) => maxBindingDistance_simple(zoom),\n   );\n \n-  getNonDeletedElements(scene, onlyUnbound).forEach((element) => {\n-    scene.mutateElement(element, {\n-      boundElements: element.boundElements?.filter(\n-        (element) =>\n-          element.type !== \"arrow\" || element.id !== linearElement.id,\n-      ),\n-    });\n-  });\n+  const current = hit\n+    ? {\n+        element: hit,\n+        mode: \"orbit\" as const,\n+        focusPoint: LinearElementEditor.getPointAtIndexGlobalCoordinates(\n+          arrow,\n+          pointIdx,\n+          elementsMap,\n+        ),\n+      }\n+    : {\n+        mode: null,\n+      };\n+  const other = { mode: undefined };\n+\n+  return pointIdx === 0\n+    ? { start: current, end: other }\n+    : { start: other, end: current };\n };\n \n-const bindOrUnbindLinearElementEdge = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n-  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n-  startOrEnd: \"start\" | \"end\",\n-  // Is mutated\n-  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n-  // Is mutated\n-  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n-  scene: Scene,\n-  elementsMap: ElementsMap,\n-): void => {\n-  // \"keep\" is for method chaining convenience, a \"no-op\", so just bail out\n-  if (bindableElement === \"keep\") {\n-    return;\n+const bindingStrategyForNewSimpleArrowEndpointDragging = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  draggingPoints: PointsPositionUpdates,\n+  elementsMap: NonDeletedSceneElementsMap,\n+  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n+  startDragged: boolean,\n+  endDragged: boolean,\n+  startIdx: number,\n+  endIdx: number,\n+  appState: AppState,\n+  globalBindMode?: AppState[\"bindMode\"],\n+  shiftKey?: boolean,\n+): {\n+  start: BindingStrategy;\n+  end: BindingStrategy;\n+} => {\n+  let start: BindingStrategy = { mode: undefined };\n+  let end: BindingStrategy = { mode: undefined };\n+\n+  const isMultiPoint = arrow.points.length > 2;\n+  const point = LinearElementEditor.getPointGlobalCoordinates(\n+    arrow,\n+    draggingPoints.get(startDragged ? startIdx : endIdx)!.point,\n+    elementsMap,\n+  );\n+  const hit = getHoveredElementForBinding(point, elements, elementsMap);\n+\n+  // With new arrows this handles the binding at arrow creation\n+  if (startDragged) {\n+    if (hit) {\n+      start = {\n+        element: hit,\n+        mode: \"inside\",\n+        focusPoint: point,\n+      };\n+    } else {\n+      start = { mode: null };\n+    }\n+\n+    return { start, end };\n   }\n \n-  // null means break the bind, so nothing to consider here\n-  if (bindableElement === null) {\n-    const unbound = unbindLinearElement(linearElement, startOrEnd, scene);\n-    if (unbound != null) {\n-      unboundFromElementIds.add(unbound);\n+  // With new arrows it represents the continuous dragging of the end point\n+  if (endDragged) {\n+    const origin = appState?.selectedLinearElement?.initialState.origin;\n+\n+    // Inside -> inside binding\n+    if (hit && arrow.startBinding?.elementId === hit.id) {\n+      const center = pointFrom<GlobalPoint>(\n+        hit.x + hit.width / 2,\n+        hit.y + hit.height / 2,\n+      );\n+\n+      return {\n+        start: isMultiPoint\n+          ? { mode: undefined }\n+          : {\n+              mode: \"inside\",\n+              element: hit,\n+              focusPoint: origin ?? center,\n+            },\n+        end: isMultiPoint\n+          ? { mode: \"orbit\", element: hit, focusPoint: point }\n+          : { mode: \"inside\", element: hit, focusPoint: point },\n+      };\n     }\n-    return;\n-  }\n \n-  // While complext arrows can do anything, simple arrow with both ends trying\n-  // to bind to the same bindable should not be allowed, start binding takes\n-  // precedence\n-  if (isLinearElementSimple(linearElement)) {\n-    if (\n-      otherEdgeBindableElement == null ||\n-      (otherEdgeBindableElement === \"keep\"\n-        ? // TODO: Refactor - Needlessly complex\n-          !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n-            linearElement,\n-            bindableElement,\n-            startOrEnd,\n-          )\n-        : startOrEnd === \"start\" ||\n-          otherEdgeBindableElement.id !== bindableElement.id)\n-    ) {\n-      bindLinearElement(linearElement, bindableElement, startOrEnd, scene);\n-      boundToElementIds.add(bindableElement.id);\n+    // Check and handle nested shapes\n+    if (hit && arrow.startBinding) {\n+      const startBinding = arrow.startBinding;\n+      const allHits = getAllHoveredElementAtPoint(point, elements, elementsMap);\n+\n+      if (allHits.find((el) => el.id === startBinding.elementId)) {\n+        const otherElement = elementsMap.get(\n+          arrow.startBinding.elementId,\n+        ) as ExcalidrawBindableElement;\n+\n+        invariant(otherElement, \"Other element must be in the elements map\");\n+\n+        return {\n+          start: isMultiPoint\n+            ? { mode: undefined }\n+            : {\n+                mode: otherElement.id !== hit.id ? \"orbit\" : \"inside\",\n+                element: otherElement,\n+                focusPoint: origin ?? pointFrom<GlobalPoint>(arrow.x, arrow.y),\n+              },\n+          end: {\n+            mode: \"orbit\",\n+            element: hit,\n+            focusPoint: point,\n+          },\n+        };\n+      }\n     }\n-  } else {\n-    bindLinearElement(linearElement, bindableElement, startOrEnd, scene);\n-    boundToElementIds.add(bindableElement.id);\n-  }\n-};\n \n-const getOriginalBindingsIfStillCloseToArrowEnds = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  elementsMap: NonDeletedSceneElementsMap,\n-  zoom?: AppState[\"zoom\"],\n-): (NonDeleted<ExcalidrawElement> | null)[] =>\n-  ([\"start\", \"end\"] as const).map((edge) => {\n-    const coors = getLinearElementEdgeCoors(linearElement, edge, elementsMap);\n-    const elementId =\n-      edge === \"start\"\n-        ? linearElement.startBinding?.elementId\n-        : linearElement.endBinding?.elementId;\n-    if (elementId) {\n-      const element = elementsMap.get(elementId);\n-      if (\n-        isBindableElement(element) &&\n-        bindingBorderTest(element, coors, elementsMap, zoom)\n-      ) {\n-        return element;\n+    // Inside -> outside binding\n+    if (arrow.startBinding && arrow.startBinding.elementId !== hit?.id) {\n+      const otherElement = elementsMap.get(\n+        arrow.startBinding.elementId,\n+      ) as ExcalidrawBindableElement;\n+      invariant(otherElement, \"Other element must be in the elements map\");\n+\n+      const otherIsInsideBinding =\n+        !!appState.selectedLinearElement?.initialState.arrowStartIsInside;\n+      const other: BindingStrategy = {\n+        mode: otherIsInsideBinding ? \"inside\" : \"orbit\",\n+        element: otherElement,\n+        focusPoint: shiftKey\n+          ? elementCenterPoint(otherElement, elementsMap)\n+          : origin ?? pointFrom<GlobalPoint>(arrow.x, arrow.y),\n+      };\n+\n+      // We are hovering another element with the end point\n+      const isNested =\n+        hit &&\n+        isBindableElementInsideOtherBindable(otherElement, hit, elementsMap);\n+      let current: BindingStrategy;\n+      if (hit) {\n+        const isInsideBinding =\n+          globalBindMode === \"inside\" || globalBindMode === \"skip\";\n+        current = {\n+          mode: isInsideBinding && !isNested ? \"inside\" : \"orbit\",\n+          element: hit,\n+          focusPoint: isInsideBinding || isNested ? point : point,\n+        };\n+      } else {\n+        current = { mode: null };\n       }\n+\n+      return {\n+        start: isMultiPoint ? { mode: undefined } : other,\n+        end: current,\n+      };\n     }\n \n-    return null;\n-  });\n+    // No start binding\n+    if (!arrow.startBinding) {\n+      if (hit) {\n+        const isInsideBinding =\n+          globalBindMode === \"inside\" || globalBindMode === \"skip\";\n+\n+        end = {\n+          mode: isInsideBinding ? \"inside\" : \"orbit\",\n+          element: hit,\n+          focusPoint: point,\n+        };\n+      } else {\n+        end = { mode: null };\n+      }\n \n-const getBindingStrategyForDraggingArrowEndpoints = (\n-  selectedElement: NonDeleted<ExcalidrawLinearElement>,\n-  isBindingEnabled: boolean,\n-  draggingPoints: readonly number[],\n-  elementsMap: NonDeletedSceneElementsMap,\n-  elements: readonly NonDeletedExcalidrawElement[],\n-  zoom?: AppState[\"zoom\"],\n-): (NonDeleted<ExcalidrawBindableElement> | null | \"keep\")[] => {\n-  const startIdx = 0;\n-  const endIdx = selectedElement.points.length - 1;\n-  const startDragged = draggingPoints.findIndex((i) => i === startIdx) > -1;\n-  const endDragged = draggingPoints.findIndex((i) => i === endIdx) > -1;\n-  const start = startDragged\n-    ? isBindingEnabled\n-      ? getEligibleElementForBindingElement(\n-          selectedElement,\n-          \"start\",\n-          elementsMap,\n-          elements,\n-          zoom,\n-        )\n-      : null // If binding is disabled and start is dragged, break all binds\n-    : \"keep\";\n-  const end = endDragged\n-    ? isBindingEnabled\n-      ? getEligibleElementForBindingElement(\n-          selectedElement,\n-          \"end\",\n-          elementsMap,\n-          elements,\n-          zoom,\n-        )\n-      : null // If binding is disabled and end is dragged, break all binds\n-    : \"keep\";\n+      return { start, end };\n+    }\n+  }\n \n-  return [start, end];\n+  invariant(false, \"New arrow creation should not reach here\");\n };\n \n-const getBindingStrategyForDraggingArrowOrJoints = (\n-  selectedElement: NonDeleted<ExcalidrawLinearElement>,\n+const bindingStrategyForSimpleArrowEndpointDragging_complex = (\n+  point: GlobalPoint,\n+  currentBinding: FixedPointBinding | null,\n+  oppositeBinding: FixedPointBinding | null,\n   elementsMap: NonDeletedSceneElementsMap,\n-  elements: readonly NonDeletedExcalidrawElement[],\n-  isBindingEnabled: boolean,\n-  zoom?: AppState[\"zoom\"],\n-): (NonDeleted<ExcalidrawBindableElement> | null | \"keep\")[] => {\n-  // Elbow arrows don't bind when dragged as a whole\n-  if (isElbowArrow(selectedElement)) {\n-    return [\"keep\", \"keep\"];\n+  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n+  globalBindMode: AppState[\"bindMode\"],\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  finalize?: boolean,\n+): { current: BindingStrategy; other: BindingStrategy } => {\n+  let current: BindingStrategy = { mode: undefined };\n+  let other: BindingStrategy = { mode: undefined };\n+\n+  const isMultiPoint = arrow.points.length > 2;\n+  const hit = getHoveredElementForBinding(point, elements, elementsMap);\n+  const isOverlapping = oppositeBinding\n+    ? getAllHoveredElementAtPoint(point, elements, elementsMap).some(\n+        (el) => el.id === oppositeBinding.elementId,\n+      )\n+    : false;\n+  const oppositeElement = oppositeBinding\n+    ? (elementsMap.get(oppositeBinding.elementId) as ExcalidrawBindableElement)\n+    : null;\n+  const otherIsTransparent =\n+    isOverlapping && oppositeElement\n+      ? isTransparent(oppositeElement.backgroundColor)\n+      : false;\n+  const isNested =\n+    hit &&\n+    oppositeElement &&\n+    isBindableElementInsideOtherBindable(oppositeElement, hit, elementsMap);\n+\n+  // If the global bind mode is in free binding mode, just bind\n+  // where the pointer is and keep the other end intact\n+  if (globalBindMode === \"inside\" || globalBindMode === \"skip\") {\n+    current = hit\n+      ? {\n+          element:\n+            !isOverlapping || !oppositeElement || otherIsTransparent\n+              ? hit\n+              : oppositeElement,\n+          focusPoint: point,\n+          mode: \"inside\",\n+        }\n+      : { mode: null };\n+    other =\n+      finalize && hit && hit.id === oppositeBinding?.elementId\n+        ? { mode: null }\n+        : other;\n+\n+    return { current, other };\n   }\n \n-  const [startIsClose, endIsClose] = getOriginalBindingsIfStillCloseToArrowEnds(\n-    selectedElement,\n-    elementsMap,\n-    zoom,\n-  );\n-  const start = startIsClose\n-    ? isBindingEnabled\n-      ? getEligibleElementForBindingElement(\n-          selectedElement,\n-          \"start\",\n-          elementsMap,\n-          elements,\n-          zoom,\n-        )\n-      : null\n-    : null;\n-  const end = endIsClose\n-    ? isBindingEnabled\n-      ? getEligibleElementForBindingElement(\n-          selectedElement,\n-          \"end\",\n-          elementsMap,\n-          elements,\n-          zoom,\n-        )\n-      : null\n-    : null;\n+  // Dragged point is outside of any bindable element\n+  // so we break any existing binding\n+  if (!hit) {\n+    return { current: { mode: null }, other };\n+  }\n \n-  return [start, end];\n-};\n+  // Already inside binding over the same hit element should remain inside bound\n+  if (\n+    hit.id === currentBinding?.elementId &&\n+    currentBinding.mode === \"inside\"\n+  ) {\n+    return {\n+      current: { mode: \"inside\", focusPoint: point, element: hit },\n+      other,\n+    };\n+  }\n \n-export const bindOrUnbindLinearElements = (\n-  selectedElements: NonDeleted<ExcalidrawLinearElement>[],\n-  isBindingEnabled: boolean,\n-  draggingPoints: readonly number[] | null,\n-  scene: Scene,\n-  zoom?: AppState[\"zoom\"],\n-): void => {\n-  selectedElements.forEach((selectedElement) => {\n-    const [start, end] = draggingPoints?.length\n-      ? // The arrow edge points are dragged (i.e. start, end)\n-        getBindingStrategyForDraggingArrowEndpoints(\n-          selectedElement,\n-          isBindingEnabled,\n-          draggingPoints ?? [],\n-          scene.getNonDeletedElementsMap(),\n-          scene.getNonDeletedElements(),\n-          zoom,\n-        )\n-      : // The arrow itself (the shaft) or the inner joins are dragged\n-        getBindingStrategyForDraggingArrowOrJoints(\n-          selectedElement,\n-          scene.getNonDeletedElementsMap(),\n-          scene.getNonDeletedElements(),\n-          isBindingEnabled,\n-          zoom,\n-        );\n+  // The dragged point is inside the hovered bindable element\n+  if (oppositeBinding) {\n+    // The opposite binding is on the same element\n+    if (oppositeBinding.elementId === hit.id) {\n+      // The opposite binding is on the binding gap of the same element\n+      if (oppositeBinding.mode === \"orbit\") {\n+        current = { element: hit, mode: \"orbit\", focusPoint: point };\n+        other = { mode: finalize ? null : undefined };\n \n-    bindOrUnbindLinearElement(selectedElement, start, end, scene);\n-  });\n+        return { current, other: isMultiPoint ? { mode: undefined } : other };\n+      }\n+      // The opposite binding is inside the same element\n+      // eslint-disable-next-line no-else-return\n+      else {\n+        current = { element: hit, mode: \"inside\", focusPoint: point };\n+\n+        return { current, other: isMultiPoint ? { mode: undefined } : other };\n+      }\n+    }\n+    // The opposite binding is on a different element (or nested)\n+    // eslint-disable-next-line no-else-return\n+    else {\n+      // Handle the nested element case\n+      if (isOverlapping && oppositeElement && !otherIsTransparent) {\n+        current = {\n+          element: oppositeElement,\n+          mode: \"inside\",\n+          focusPoint: point,\n+        };\n+      } else {\n+        current = {\n+          element: hit,\n+          mode: \"orbit\",\n+          focusPoint: isNested ? point : point,\n+        };\n+      }\n+\n+      return { current, other: isMultiPoint ? { mode: undefined } : other };\n+    }\n+  }\n+  // The opposite binding is on a different element or no binding\n+  else {\n+    current = {\n+      element: hit,\n+      mode: \"orbit\",\n+      focusPoint: point,\n+    };\n+  }\n+\n+  // Must return as only one endpoint is dragged, therefore\n+  // the end binding strategy might accidentally gets overriden\n+  return { current, other: isMultiPoint ? { mode: undefined } : other };\n };\n \n-export const getSuggestedBindingsForArrows = (\n-  selectedElements: NonDeleted<ExcalidrawElement>[],\n+export const getBindingStrategyForDraggingBindingElementEndpoints = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  draggingPoints: PointsPositionUpdates,\n   elementsMap: NonDeletedSceneElementsMap,\n-  zoom: AppState[\"zoom\"],\n-): SuggestedBinding[] => {\n-  // HOT PATH: Bail out if selected elements list is too large\n-  if (selectedElements.length > 50) {\n-    return [];\n+  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n+  appState: AppState,\n+  opts?: {\n+    newArrow?: boolean;\n+    shiftKey?: boolean;\n+    altKey?: boolean;\n+    finalize?: boolean;\n+    initialBinding?: boolean;\n+    zoom?: AppState[\"zoom\"];\n+  },\n+): { start: BindingStrategy; end: BindingStrategy } => {\n+  if (getFeatureFlag(\"COMPLEX_BINDINGS\")) {\n+    return getBindingStrategyForDraggingBindingElementEndpoints_complex(\n+      arrow,\n+      draggingPoints,\n+      elementsMap,\n+      elements,\n+      appState,\n+      opts,\n+    );\n   }\n \n-  return (\n-    selectedElements\n-      .filter(isLinearElement)\n-      .flatMap((element) =>\n-        getOriginalBindingsIfStillCloseToArrowEnds(element, elementsMap, zoom),\n-      )\n-      .filter(\n-        (element): element is NonDeleted<ExcalidrawBindableElement> =>\n-          element !== null,\n-      )\n-      // Filter out bind candidates which are in the\n-      // same selection / group with the arrow\n-      //\n-      // TODO: Is it worth turning the list into a set to avoid dupes?\n-      .filter(\n-        (element) =>\n-          selectedElements.filter((selected) => selected.id === element?.id)\n-            .length === 0,\n-      )\n+  return getBindingStrategyForDraggingBindingElementEndpoints_simple(\n+    arrow,\n+    draggingPoints,\n+    elementsMap,\n+    elements,\n+    appState,\n+    opts,\n   );\n };\n \n-export const maybeSuggestBindingsForLinearElementAtCoords = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  /** scene coords */\n-  pointerCoords: {\n-    x: number;\n-    y: number;\n-  }[],\n-  scene: Scene,\n-  zoom: AppState[\"zoom\"],\n-  // During line creation the start binding hasn't been written yet\n-  // into `linearElement`\n-  oppositeBindingBoundElement?: ExcalidrawBindableElement | null,\n-): ExcalidrawBindableElement[] =>\n-  Array.from(\n-    pointerCoords.reduce(\n-      (acc: Set<NonDeleted<ExcalidrawBindableElement>>, coords) => {\n-        const hoveredBindableElement = getHoveredElementForBinding(\n-          coords,\n-          scene.getNonDeletedElements(),\n-          scene.getNonDeletedElementsMap(),\n-          zoom,\n-          isElbowArrow(linearElement),\n-          isElbowArrow(linearElement),\n-        );\n+const getBindingStrategyForDraggingBindingElementEndpoints_simple = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  draggingPoints: PointsPositionUpdates,\n+  elementsMap: NonDeletedSceneElementsMap,\n+  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n+  appState: AppState,\n+  opts?: {\n+    newArrow?: boolean;\n+    shiftKey?: boolean;\n+    altKey?: boolean;\n+    finalize?: boolean;\n+    initialBinding?: boolean;\n+    zoom?: AppState[\"zoom\"];\n+  },\n+): { start: BindingStrategy; end: BindingStrategy } => {\n+  const startIdx = 0;\n+  const endIdx = arrow.points.length - 1;\n+  const startDragged = draggingPoints.has(startIdx);\n+  const endDragged = draggingPoints.has(endIdx);\n \n-        if (\n-          hoveredBindableElement != null &&\n-          !isLinearElementSimpleAndAlreadyBound(\n-            linearElement,\n-            oppositeBindingBoundElement?.id,\n-            hoveredBindableElement,\n-          )\n-        ) {\n-          acc.add(hoveredBindableElement);\n-        }\n+  let start: BindingStrategy = { mode: undefined };\n+  let end: BindingStrategy = { mode: undefined };\n \n-        return acc;\n-      },\n-      new Set() as Set<NonDeleted<ExcalidrawBindableElement>>,\n-    ),\n+  invariant(\n+    arrow.points.length > 1,\n+    \"Do not attempt to bind linear elements with a single point\",\n   );\n \n-export const maybeBindLinearElement = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  appState: AppState,\n-  pointerCoords: { x: number; y: number },\n-  scene: Scene,\n-): void => {\n-  const elements = scene.getNonDeletedElements();\n-  const elementsMap = scene.getNonDeletedElementsMap();\n+  // If none of the ends are dragged, we don't change anything\n+  if (!startDragged && !endDragged) {\n+    return { start, end };\n+  }\n \n-  if (appState.startBoundElement != null) {\n-    bindLinearElement(\n-      linearElement,\n-      appState.startBoundElement,\n-      \"start\",\n-      scene,\n+  // If both ends are dragged, we don't bind to anything\n+  // and break existing bindings\n+  if (startDragged && endDragged) {\n+    return { start: { mode: null }, end: { mode: null } };\n+  }\n+\n+  // If binding is disabled and an endpoint is dragged,\n+  // we actively break the end binding\n+  if (!isBindingEnabled(appState)) {\n+    start = startDragged ? { mode: null } : start;\n+    end = endDragged ? { mode: null } : end;\n+\n+    return { start, end };\n+  }\n+\n+  // Handle simpler elbow arrow binding\n+  if (isElbowArrow(arrow)) {\n+    return bindingStrategyForElbowArrowEndpointDragging(\n+      arrow,\n+      draggingPoints,\n+      elementsMap,\n+      elements,\n+      opts?.zoom,\n     );\n   }\n \n-  const hoveredElement = getHoveredElementForBinding(\n-    pointerCoords,\n+  const otherBinding = startDragged ? arrow.endBinding : arrow.startBinding;\n+  const localPoint = draggingPoints.get(\n+    startDragged ? startIdx : endIdx,\n+  )?.point;\n+  invariant(\n+    localPoint,\n+    `Local point must be defined for ${\n+      startDragged ? \"start\" : \"end\"\n+    } dragging`,\n+  );\n+  const globalPoint = LinearElementEditor.getPointGlobalCoordinates(\n+    arrow,\n+    localPoint,\n+    elementsMap,\n+  );\n+  const hit = getHoveredElementForBinding(\n+    globalPoint,\n     elements,\n     elementsMap,\n-    appState.zoom,\n-    isElbowArrow(linearElement),\n-    isElbowArrow(linearElement),\n+    (e) => maxBindingDistance_simple(appState.zoom),\n   );\n+  const pointInElement = hit && isPointInElement(globalPoint, hit, elementsMap);\n+  const otherBindableElement = otherBinding\n+    ? (elementsMap.get(\n+        otherBinding.elementId,\n+      ) as NonDeleted<ExcalidrawBindableElement>)\n+    : undefined;\n+  const otherFocusPoint =\n+    otherBinding &&\n+    otherBindableElement &&\n+    getGlobalFixedPointForBindableElement(\n+      otherBinding.fixedPoint,\n+      otherBindableElement,\n+      elementsMap,\n+    );\n+  const otherFocusPointIsInElement =\n+    otherBindableElement &&\n+    otherFocusPoint &&\n+    isPointInElement(otherFocusPoint, otherBindableElement, elementsMap);\n+\n+  // Handle outside-outside binding to the same element\n+  if (otherBinding && otherBinding.elementId === hit?.id) {\n+    invariant(\n+      !opts?.newArrow || appState.selectedLinearElement?.initialState.origin,\n+      \"appState.selectedLinearElement.initialState.origin must be defined for new arrows\",\n+    );\n \n-  if (hoveredElement !== null) {\n-    if (\n-      !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n-        linearElement,\n-        hoveredElement,\n-        \"end\",\n-      )\n-    ) {\n-      bindLinearElement(linearElement, hoveredElement, \"end\", scene);\n-    }\n+    return {\n+      start: {\n+        mode: \"inside\",\n+        element: hit,\n+        focusPoint: startDragged\n+          ? globalPoint\n+          : // NOTE: Can only affect the start point because new arrows always drag the end point\n+          opts?.newArrow\n+          ? appState.selectedLinearElement!.initialState.origin!\n+          : LinearElementEditor.getPointAtIndexGlobalCoordinates(\n+              arrow,\n+              0,\n+              elementsMap,\n+            ), // startFixedPoint,\n+      },\n+      end: {\n+        mode: \"inside\",\n+        element: hit,\n+        focusPoint: endDragged\n+          ? globalPoint\n+          : LinearElementEditor.getPointAtIndexGlobalCoordinates(\n+              arrow,\n+              -1,\n+              elementsMap,\n+            ), // endFixedPoint\n+      },\n+    };\n   }\n-};\n \n-const normalizePointBinding = (\n-  binding: { focus: number; gap: number },\n-  hoveredElement: ExcalidrawBindableElement,\n-) => ({\n-  ...binding,\n-  gap: Math.min(\n-    binding.gap,\n-    maxBindingGap(hoveredElement, hoveredElement.width, hoveredElement.height),\n-  ),\n-});\n-\n-export const bindLinearElement = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  hoveredElement: ExcalidrawBindableElement,\n-  startOrEnd: \"start\" | \"end\",\n-  scene: Scene,\n-): void => {\n-  if (!isArrowElement(linearElement)) {\n-    return;\n+  // Handle special alt key case to inside bind no matter what\n+  if (opts?.altKey) {\n+    return {\n+      start: startDragged\n+        ? hit\n+          ? {\n+              mode: \"inside\",\n+              element: hit,\n+              focusPoint: globalPoint,\n+            }\n+          : { mode: null }\n+        : start,\n+      end: endDragged\n+        ? hit\n+          ? {\n+              mode: \"inside\",\n+              element: hit,\n+              focusPoint: globalPoint,\n+            }\n+          : { mode: null }\n+        : end,\n+    };\n   }\n \n-  let binding: PointBinding | FixedPointBinding = {\n-    elementId: hoveredElement.id,\n-    ...normalizePointBinding(\n-      calculateFocusAndGap(\n-        linearElement,\n-        hoveredElement,\n-        startOrEnd,\n-        scene.getNonDeletedElementsMap(),\n-      ),\n-      hoveredElement,\n-    ),\n+  // Handle normal cases\n+  const current: BindingStrategy = hit\n+    ? pointInElement\n+      ? {\n+          mode: \"inside\",\n+          element: hit,\n+          focusPoint: globalPoint,\n+        }\n+      : {\n+          mode: \"orbit\",\n+          element: hit,\n+          focusPoint:\n+            projectFixedPointOntoDiagonal(\n+              arrow,\n+              globalPoint,\n+              hit,\n+              startDragged ? \"start\" : \"end\",\n+              elementsMap,\n+            ) || globalPoint,\n+        }\n+    : { mode: null };\n+\n+  const other: BindingStrategy =\n+    otherBindableElement &&\n+    !otherFocusPointIsInElement &&\n+    appState.selectedLinearElement?.initialState.altFocusPoint\n+      ? {\n+          mode: \"orbit\",\n+          element: otherBindableElement,\n+          focusPoint: appState.selectedLinearElement.initialState.altFocusPoint,\n+        }\n+      : { mode: undefined };\n+\n+  return {\n+    start: startDragged ? current : other,\n+    end: endDragged ? current : other,\n   };\n+};\n \n-  if (isElbowArrow(linearElement)) {\n-    binding = {\n-      ...binding,\n-      ...calculateFixedPointForElbowArrowBinding(\n-        linearElement,\n-        hoveredElement,\n-        startOrEnd,\n-        scene.getNonDeletedElementsMap(),\n-      ),\n-    };\n-  }\n+const getBindingStrategyForDraggingBindingElementEndpoints_complex = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  draggingPoints: PointsPositionUpdates,\n+  elementsMap: NonDeletedSceneElementsMap,\n+  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n+  appState: AppState,\n+  opts?: {\n+    newArrow?: boolean;\n+    shiftKey?: boolean;\n+    finalize?: boolean;\n+    initialBinding?: boolean;\n+  },\n+): { start: BindingStrategy; end: BindingStrategy } => {\n+  const globalBindMode = appState.bindMode || \"orbit\";\n+  const startIdx = 0;\n+  const endIdx = arrow.points.length - 1;\n+  const startDragged = draggingPoints.has(startIdx);\n+  const endDragged = draggingPoints.has(endIdx);\n \n-  scene.mutateElement(linearElement, {\n-    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding,\n-  });\n+  let start: BindingStrategy = { mode: undefined };\n+  let end: BindingStrategy = { mode: undefined };\n \n-  const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);\n-  if (!boundElementsMap.has(linearElement.id)) {\n-    scene.mutateElement(hoveredElement, {\n-      boundElements: (hoveredElement.boundElements || []).concat({\n-        id: linearElement.id,\n-        type: \"arrow\",\n-      }),\n-    });\n+  invariant(\n+    arrow.points.length > 1,\n+    \"Do not attempt to bind linear elements with a single point\",\n+  );\n+\n+  // If none of the ends are dragged, we don't change anything\n+  if (!startDragged && !endDragged) {\n+    return { start, end };\n   }\n-};\n \n-// Don't bind both ends of a simple segment\n-const isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  bindableElement: ExcalidrawBindableElement,\n-  startOrEnd: \"start\" | \"end\",\n-): boolean => {\n-  const otherBinding =\n-    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n-  return isLinearElementSimpleAndAlreadyBound(\n-    linearElement,\n-    otherBinding?.elementId,\n-    bindableElement,\n-  );\n-};\n+  // If both ends are dragged, we don't bind to anything\n+  // and break existing bindings\n+  if (startDragged && endDragged) {\n+    return { start: { mode: null }, end: { mode: null } };\n+  }\n \n-export const isLinearElementSimpleAndAlreadyBound = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n-  bindableElement: ExcalidrawBindableElement,\n-): boolean => {\n-  return (\n-    alreadyBoundToId === bindableElement.id &&\n-    isLinearElementSimple(linearElement)\n-  );\n-};\n+  // If binding is disabled and an endpoint is dragged,\n+  // we actively break the end binding\n+  if (!isBindingEnabled(appState)) {\n+    start = startDragged ? { mode: null } : start;\n+    end = endDragged ? { mode: null } : end;\n \n-const isLinearElementSimple = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-): boolean => linearElement.points.length < 3 && !isElbowArrow(linearElement);\n+    return { start, end };\n+  }\n \n-const unbindLinearElement = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  startOrEnd: \"start\" | \"end\",\n-  scene: Scene,\n-): ExcalidrawBindableElement[\"id\"] | null => {\n-  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n-  const binding = linearElement[field];\n-  if (binding == null) {\n-    return null;\n+  // Handle simpler elbow arrow binding\n+  if (isElbowArrow(arrow)) {\n+    return bindingStrategyForElbowArrowEndpointDragging(\n+      arrow,\n+      draggingPoints,\n+      elementsMap,\n+      elements,\n+    );\n   }\n-  scene.mutateElement(linearElement, { [field]: null });\n-  return binding.elementId;\n-};\n \n-export const getHoveredElementForBinding = (\n-  pointerCoords: {\n-    x: number;\n-    y: number;\n-  },\n-  elements: readonly NonDeletedExcalidrawElement[],\n-  elementsMap: NonDeletedSceneElementsMap,\n-  zoom?: AppState[\"zoom\"],\n-  fullShape?: boolean,\n-  considerAllElements?: boolean,\n-): NonDeleted<ExcalidrawBindableElement> | null => {\n-  if (considerAllElements) {\n-    let cullRest = false;\n-    const candidateElements = getAllElementsAtPositionForBinding(\n+  // Handle new arrow creation separately, as it is special\n+  if (opts?.newArrow) {\n+    const { start, end } = bindingStrategyForNewSimpleArrowEndpointDragging(\n+      arrow,\n+      draggingPoints,\n+      elementsMap,\n       elements,\n-      (element) =>\n-        isBindableElement(element, false) &&\n-        bindingBorderTest(\n-          element,\n-          pointerCoords,\n-          elementsMap,\n-          zoom,\n-          (fullShape ||\n-            !isBindingFallthroughEnabled(\n-              element as ExcalidrawBindableElement,\n-            )) &&\n-            // disable fullshape snapping for frame elements so we\n-            // can bind to frame children\n-            !isFrameLikeElement(element),\n-        ),\n-    ).filter((element) => {\n-      if (cullRest) {\n-        return false;\n-      }\n+      startDragged,\n+      endDragged,\n+      startIdx,\n+      endIdx,\n+      appState,\n+      globalBindMode,\n+      opts?.shiftKey,\n+    );\n \n-      if (!isBindingFallthroughEnabled(element as ExcalidrawBindableElement)) {\n-        cullRest = true;\n-      }\n+    return { start, end };\n+  }\n \n-      return true;\n-    }) as NonDeleted<ExcalidrawBindableElement>[] | null;\n+  // Only the start point is dragged\n+  if (startDragged) {\n+    const localPoint = draggingPoints.get(startIdx)?.point;\n+    invariant(localPoint, \"Local point must be defined for start dragging\");\n+    const globalPoint = LinearElementEditor.getPointGlobalCoordinates(\n+      arrow,\n+      localPoint,\n+      elementsMap,\n+    );\n \n-    // Return early if there are no candidates or just one candidate\n-    if (!candidateElements || candidateElements.length === 0) {\n-      return null;\n-    }\n+    const { current, other } =\n+      bindingStrategyForSimpleArrowEndpointDragging_complex(\n+        globalPoint,\n+        arrow.startBinding,\n+        arrow.endBinding,\n+        elementsMap,\n+        elements,\n+        globalBindMode,\n+        arrow,\n+        opts?.finalize,\n+      );\n \n-    if (candidateElements.length === 1) {\n-      return candidateElements[0] as NonDeleted<ExcalidrawBindableElement>;\n-    }\n+    return { start: current, end: other };\n+  }\n \n-    // Prefer the shape with the border being tested (if any)\n-    const borderTestElements = candidateElements.filter((element) =>\n-      bindingBorderTest(element, pointerCoords, elementsMap, zoom, false),\n+  // Only the end point is dragged\n+  if (endDragged) {\n+    const localPoint = draggingPoints.get(endIdx)?.point;\n+    invariant(localPoint, \"Local point must be defined for end dragging\");\n+    const globalPoint = LinearElementEditor.getPointGlobalCoordinates(\n+      arrow,\n+      localPoint,\n+      elementsMap,\n     );\n-    if (borderTestElements.length === 1) {\n-      return borderTestElements[0];\n-    }\n+    const { current, other } =\n+      bindingStrategyForSimpleArrowEndpointDragging_complex(\n+        globalPoint,\n+        arrow.endBinding,\n+        arrow.startBinding,\n+        elementsMap,\n+        elements,\n+        globalBindMode,\n+        arrow,\n+        opts?.finalize,\n+      );\n \n-    // Prefer smaller shapes\n-    return candidateElements\n-      .sort(\n-        (a, b) => b.width ** 2 + b.height ** 2 - (a.width ** 2 + a.height ** 2),\n-      )\n-      .pop() as NonDeleted<ExcalidrawBindableElement>;\n+    return { start: other, end: current };\n   }\n \n-  const hoveredElement = getElementAtPositionForBinding(\n-    elements,\n-    (element) =>\n-      isBindableElement(element, false) &&\n-      bindingBorderTest(\n-        element,\n-        pointerCoords,\n+  return { start, end };\n+};\n+\n+export const bindOrUnbindBindingElements = (\n+  selectedArrows: NonDeleted<ExcalidrawArrowElement>[],\n+  scene: Scene,\n+  appState: AppState,\n+): void => {\n+  selectedArrows.forEach((arrow) => {\n+    bindOrUnbindBindingElement(\n+      arrow,\n+      new Map(), // No dragging points in this case\n+      scene,\n+      appState,\n+    );\n+  });\n+};\n+\n+export const bindBindingElement = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  hoveredElement: ExcalidrawBindableElement,\n+  mode: BindMode,\n+  startOrEnd: \"start\" | \"end\",\n+  scene: Scene,\n+  focusPoint?: GlobalPoint,\n+): void => {\n+  const elementsMap = scene.getNonDeletedElementsMap();\n+\n+  let binding: FixedPointBinding;\n+\n+  if (isElbowArrow(arrow)) {\n+    binding = {\n+      elementId: hoveredElement.id,\n+      mode: \"orbit\",\n+      ...calculateFixedPointForElbowArrowBinding(\n+        arrow,\n+        hoveredElement,\n+        startOrEnd,\n         elementsMap,\n-        zoom,\n-        // disable fullshape snapping for frame elements so we\n-        // can bind to frame children\n-        (fullShape || !isBindingFallthroughEnabled(element)) &&\n-          !isFrameLikeElement(element),\n       ),\n-  );\n+    };\n+  } else {\n+    binding = {\n+      elementId: hoveredElement.id,\n+      mode,\n+      ...calculateFixedPointForNonElbowArrowBinding(\n+        arrow,\n+        hoveredElement,\n+        startOrEnd,\n+        elementsMap,\n+        focusPoint,\n+      ),\n+    };\n+  }\n \n-  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n-};\n+  scene.mutateElement(arrow, {\n+    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding,\n+  });\n \n-const getElementAtPositionForBinding = (\n-  elements: readonly NonDeletedExcalidrawElement[],\n-  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n-) => {\n-  let hitElement = null;\n-  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n-  // because array is ordered from lower z-index to highest and we want element z-index\n-  // with higher z-index\n-  for (let index = elements.length - 1; index >= 0; --index) {\n-    const element = elements[index];\n-    if (element.isDeleted) {\n-      continue;\n-    }\n-    if (isAtPositionFn(element)) {\n-      hitElement = element;\n-      break;\n-    }\n+  const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);\n+  if (!boundElementsMap.has(arrow.id)) {\n+    scene.mutateElement(hoveredElement, {\n+      boundElements: (hoveredElement.boundElements || []).concat({\n+        id: arrow.id,\n+        type: \"arrow\",\n+      }),\n+    });\n   }\n-\n-  return hitElement;\n };\n \n-const getAllElementsAtPositionForBinding = (\n-  elements: readonly NonDeletedExcalidrawElement[],\n-  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n-) => {\n-  const elementsAtPosition: NonDeletedExcalidrawElement[] = [];\n-  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n-  // because array is ordered from lower z-index to highest and we want element z-index\n-  // with higher z-index\n-  for (let index = elements.length - 1; index >= 0; --index) {\n-    const element = elements[index];\n-    if (element.isDeleted) {\n-      continue;\n-    }\n+export const unbindBindingElement = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n+  startOrEnd: \"start\" | \"end\",\n+  scene: Scene,\n+): ExcalidrawBindableElement[\"id\"] | null => {\n+  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n+  const binding = arrow[field];\n \n-    if (isAtPositionFn(element)) {\n-      elementsAtPosition.push(element);\n-    }\n+  if (binding == null) {\n+    return null;\n   }\n \n-  return elementsAtPosition;\n-};\n-\n-const calculateFocusAndGap = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  hoveredElement: ExcalidrawBindableElement,\n-  startOrEnd: \"start\" | \"end\",\n-  elementsMap: NonDeletedSceneElementsMap,\n-): { focus: number; gap: number } => {\n-  const direction = startOrEnd === \"start\" ? -1 : 1;\n-  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n-  const adjacentPointIndex = edgePointIndex - direction;\n+  const oppositeBinding =\n+    arrow[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n+  if (!oppositeBinding || oppositeBinding.elementId !== binding.elementId) {\n+    // Only remove the record on the bound element if the other\n+    // end is not bound to the same element\n+    const boundElement = scene\n+      .getNonDeletedElementsMap()\n+      .get(binding.elementId) as ExcalidrawBindableElement;\n+    scene.mutateElement(boundElement, {\n+      boundElements: boundElement.boundElements?.filter(\n+        (element) => element.id !== arrow.id,\n+      ),\n+    });\n+  }\n \n-  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n-    linearElement,\n-    edgePointIndex,\n-    elementsMap,\n-  );\n-  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n-    linearElement,\n-    adjacentPointIndex,\n-    elementsMap,\n-  );\n+  scene.mutateElement(arrow, { [field]: null });\n \n-  return {\n-    focus: determineFocusDistance(\n-      hoveredElement,\n-      elementsMap,\n-      adjacentPoint,\n-      edgePoint,\n-    ),\n-    gap: Math.max(1, distanceToElement(hoveredElement, elementsMap, edgePoint)),\n-  };\n+  return binding.elementId;\n };\n \n // Supports translating, rotating and scaling `changedElement` with bound\n@@ -740,7 +1021,6 @@ export const updateBoundElements = (\n   scene: Scene,\n   options?: {\n     simultaneouslyUpdated?: readonly ExcalidrawElement[];\n-    newSize?: { width: number; height: number };\n     changedElements?: Map<string, ExcalidrawElement>;\n   },\n ) => {\n@@ -748,7 +1028,7 @@ export const updateBoundElements = (\n     return;\n   }\n \n-  const { newSize, simultaneouslyUpdated } = options ?? {};\n+  const { simultaneouslyUpdated } = options ?? {};\n   const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n     simultaneouslyUpdated,\n   );\n@@ -762,7 +1042,7 @@ export const updateBoundElements = (\n   }\n \n   boundElementsVisitor(elementsMap, changedElement, (element) => {\n-    if (!isLinearElement(element) || element.isDeleted) {\n+    if (!isArrowElement(element) || element.isDeleted) {\n       return;\n     }\n \n@@ -776,32 +1056,14 @@ export const updateBoundElements = (\n       ? elementsMap.get(element.startBinding.elementId)\n       : null;\n     const endBindingElement = element.endBinding\n-      ? elementsMap.get(element.endBinding.elementId)\n+      ? // PERF: If the arrow is bound to the same element on both ends.\n+        startBindingElement?.id === element.endBinding.elementId\n+        ? startBindingElement\n+        : elementsMap.get(element.endBinding.elementId)\n       : null;\n \n-    let startBounds: Bounds | null = null;\n-    let endBounds: Bounds | null = null;\n-    if (startBindingElement && endBindingElement) {\n-      startBounds = getElementBounds(startBindingElement, elementsMap);\n-      endBounds = getElementBounds(endBindingElement, elementsMap);\n-    }\n-\n-    const bindings = {\n-      startBinding: maybeCalculateNewGapWhenScaling(\n-        changedElement,\n-        element.startBinding,\n-        newSize,\n-      ),\n-      endBinding: maybeCalculateNewGapWhenScaling(\n-        changedElement,\n-        element.endBinding,\n-        newSize,\n-      ),\n-    };\n-\n     // `linearElement` is being moved/scaled already, just update the binding\n     if (simultaneouslyUpdatedElementIds.has(element.id)) {\n-      scene.mutateElement(element, bindings);\n       return;\n     }\n \n@@ -814,16 +1076,15 @@ export const updateBoundElements = (\n           isBindableElement(bindableElement) &&\n           (bindingProp === \"startBinding\" || bindingProp === \"endBinding\") &&\n           (changedElement.id === element[bindingProp]?.elementId ||\n-            (changedElement.id ===\n+            changedElement.id ===\n               element[\n                 bindingProp === \"startBinding\" ? \"endBinding\" : \"startBinding\"\n-              ]?.elementId &&\n-              !doBoundsIntersect(startBounds, endBounds)))\n+              ]?.elementId)\n         ) {\n           const point = updateBoundPoint(\n             element,\n             bindingProp,\n-            bindings[bindingProp],\n+            element[bindingProp],\n             bindableElement,\n             elementsMap,\n           );\n@@ -843,12 +1104,9 @@ export const updateBoundElements = (\n     );\n \n     LinearElementEditor.movePoints(element, scene, new Map(updates), {\n-      ...(changedElement.id === element.startBinding?.elementId\n-        ? { startBinding: bindings.startBinding }\n-        : {}),\n-      ...(changedElement.id === element.endBinding?.elementId\n-        ? { endBinding: bindings.endBinding }\n-        : {}),\n+      moveMidPointsWithElement:\n+        !!startBindingElement &&\n+        startBindingElement?.id === endBindingElement?.id,\n     });\n \n     const boundText = getBoundTextElement(element, elementsMap);\n@@ -861,14 +1119,14 @@ export const updateBoundElements = (\n export const updateBindings = (\n   latestElement: ExcalidrawElement,\n   scene: Scene,\n+  appState: AppState,\n   options?: {\n     simultaneouslyUpdated?: readonly ExcalidrawElement[];\n     newSize?: { width: number; height: number };\n-    zoom?: AppState[\"zoom\"];\n   },\n ) => {\n-  if (isLinearElement(latestElement)) {\n-    bindOrUnbindLinearElements([latestElement], true, [], scene, options?.zoom);\n+  if (isArrowElement(latestElement)) {\n+    bindOrUnbindBindingElement(latestElement, new Map(), scene, appState);\n   } else {\n     updateBoundElements(latestElement, scene, {\n       ...options,\n@@ -878,7 +1136,7 @@ export const updateBindings = (\n };\n \n const doesNeedUpdate = (\n-  boundElement: NonDeleted<ExcalidrawLinearElement>,\n+  boundElement: NonDeleted<ExcalidrawArrowElement>,\n   changedElement: ExcalidrawBindableElement,\n ) => {\n   return (\n@@ -931,79 +1189,86 @@ const getDistanceForBinding = (\n   zoom?: AppState[\"zoom\"],\n ) => {\n   const distance = distanceToElement(bindableElement, elementsMap, point);\n-  const bindDistance = maxBindingGap(\n-    bindableElement,\n-    bindableElement.width,\n-    bindableElement.height,\n-    zoom,\n-  );\n+  const bindDistance = maxBindingDistance_simple(zoom);\n \n   return distance > bindDistance ? null : distance;\n };\n \n export const bindPointToSnapToElementOutline = (\n-  arrow: ExcalidrawElbowArrowElement,\n+  arrowElement: ExcalidrawArrowElement,\n   bindableElement: ExcalidrawBindableElement,\n   startOrEnd: \"start\" | \"end\",\n   elementsMap: ElementsMap,\n+  customIntersector?: LineSegment<GlobalPoint>,\n ): GlobalPoint => {\n-  if (isDevEnv() || isTestEnv()) {\n-    invariant(arrow.points.length > 1, \"Arrow should have at least 2 points\");\n+  const elbowed = isElbowArrow(arrowElement);\n+  const point =\n+    customIntersector && !elbowed\n+      ? customIntersector[0]\n+      : LinearElementEditor.getPointAtIndexGlobalCoordinates(\n+          arrowElement,\n+          startOrEnd === \"start\" ? 0 : -1,\n+          elementsMap,\n+        );\n+\n+  if (arrowElement.points.length < 2) {\n+    // New arrow creation, so no snapping\n+    return point;\n   }\n \n-  const aabb = aabbForElement(bindableElement, elementsMap);\n-  const localP =\n-    arrow.points[startOrEnd === \"start\" ? 0 : arrow.points.length - 1];\n-  const globalP = pointFrom<GlobalPoint>(\n-    arrow.x + localP[0],\n-    arrow.y + localP[1],\n-  );\n   const edgePoint = isRectanguloidElement(bindableElement)\n-    ? avoidRectangularCorner(bindableElement, elementsMap, globalP)\n-    : globalP;\n-  const elbowed = isElbowArrow(arrow);\n-  const center = getCenterForBounds(aabb);\n-  const adjacentPointIdx = startOrEnd === \"start\" ? 1 : arrow.points.length - 2;\n-  const adjacentPoint = pointRotateRads(\n-    pointFrom<GlobalPoint>(\n-      arrow.x + arrow.points[adjacentPointIdx][0],\n-      arrow.y + arrow.points[adjacentPointIdx][1],\n-    ),\n-    center,\n-    arrow.angle ?? 0,\n-  );\n+    ? avoidRectangularCorner(arrowElement, bindableElement, elementsMap, point)\n+    : point;\n+  const adjacentPoint =\n+    customIntersector && !elbowed\n+      ? customIntersector[1]\n+      : LinearElementEditor.getPointAtIndexGlobalCoordinates(\n+          arrowElement,\n+          startOrEnd === \"start\" ? 1 : -2,\n+          elementsMap,\n+        );\n+  const bindingGap = getBindingGap(bindableElement, arrowElement);\n+  const aabb = aabbForElement(bindableElement, elementsMap);\n+  const bindableCenter = getCenterForBounds(aabb);\n \n   let intersection: GlobalPoint | null = null;\n   if (elbowed) {\n     const isHorizontal = headingIsHorizontal(\n-      headingForPointFromElement(bindableElement, aabb, globalP),\n+      headingForPointFromElement(bindableElement, aabb, point),\n+    );\n+    const snapPoint = snapToMid(\n+      arrowElement,\n+      bindableElement,\n+      elementsMap,\n+      edgePoint,\n     );\n-    const snapPoint = snapToMid(bindableElement, elementsMap, edgePoint);\n     const otherPoint = pointFrom<GlobalPoint>(\n-      isHorizontal ? center[0] : snapPoint[0],\n-      !isHorizontal ? center[1] : snapPoint[1],\n+      isHorizontal ? bindableCenter[0] : snapPoint[0],\n+      !isHorizontal ? bindableCenter[1] : snapPoint[1],\n     );\n-    const intersector = lineSegment(\n-      otherPoint,\n-      pointFromVector(\n-        vectorScale(\n-          vectorNormalize(vectorFromPoint(snapPoint, otherPoint)),\n-          Math.max(bindableElement.width, bindableElement.height) * 2,\n-        ),\n+    const intersector =\n+      customIntersector ??\n+      lineSegment(\n         otherPoint,\n-      ),\n-    );\n+        pointFromVector(\n+          vectorScale(\n+            vectorNormalize(vectorFromPoint(snapPoint, otherPoint)),\n+            Math.max(bindableElement.width, bindableElement.height) * 2,\n+          ),\n+          otherPoint,\n+        ),\n+      );\n     intersection = intersectElementWithLineSegment(\n       bindableElement,\n       elementsMap,\n       intersector,\n-      FIXED_BINDING_DISTANCE,\n+      bindingGap,\n     ).sort(pointDistanceSq)[0];\n \n     if (!intersection) {\n       const anotherPoint = pointFrom<GlobalPoint>(\n-        !isHorizontal ? center[0] : snapPoint[0],\n-        isHorizontal ? center[1] : snapPoint[1],\n+        !isHorizontal ? bindableCenter[0] : snapPoint[0],\n+        isHorizontal ? bindableCenter[1] : snapPoint[1],\n       );\n       const anotherIntersector = lineSegment(\n         anotherPoint,\n@@ -1019,29 +1284,39 @@ export const bindPointToSnapToElementOutline = (\n         bindableElement,\n         elementsMap,\n         anotherIntersector,\n-        FIXED_BINDING_DISTANCE,\n+        BASE_BINDING_GAP_ELBOW,\n       ).sort(pointDistanceSq)[0];\n     }\n   } else {\n-    intersection = intersectElementWithLineSegment(\n-      bindableElement,\n-      elementsMap,\n-      lineSegment(\n-        adjacentPoint,\n-        pointFromVector(\n-          vectorScale(\n-            vectorNormalize(vectorFromPoint(edgePoint, adjacentPoint)),\n-            pointDistance(edgePoint, adjacentPoint) +\n-              Math.max(bindableElement.width, bindableElement.height) * 2,\n-          ),\n-          adjacentPoint,\n-        ),\n-      ),\n-      FIXED_BINDING_DISTANCE,\n-    ).sort(\n-      (g, h) =>\n-        pointDistanceSq(g, adjacentPoint) - pointDistanceSq(h, adjacentPoint),\n-    )[0];\n+    let intersector = customIntersector;\n+    if (!intersector) {\n+      const halfVector = vectorScale(\n+        vectorNormalize(vectorFromPoint(edgePoint, adjacentPoint)),\n+        pointDistance(edgePoint, adjacentPoint) +\n+          Math.max(bindableElement.width, bindableElement.height) +\n+          bindingGap * 2,\n+      );\n+      intersector =\n+        customIntersector ??\n+        lineSegment(\n+          pointFromVector(halfVector, adjacentPoint),\n+          pointFromVector(vectorScale(halfVector, -1), adjacentPoint),\n+        );\n+    }\n+\n+    intersection =\n+      pointDistance(edgePoint, adjacentPoint) < 1\n+        ? edgePoint\n+        : intersectElementWithLineSegment(\n+            bindableElement,\n+            elementsMap,\n+            intersector,\n+            bindingGap,\n+          ).sort(\n+            (g, h) =>\n+              pointDistanceSq(g, adjacentPoint) -\n+              pointDistanceSq(h, adjacentPoint),\n+          )[0];\n   }\n \n   if (\n@@ -1052,120 +1327,123 @@ export const bindPointToSnapToElementOutline = (\n     return edgePoint;\n   }\n \n-  return elbowed ? intersection : edgePoint;\n+  return intersection;\n };\n \n export const avoidRectangularCorner = (\n-  element: ExcalidrawBindableElement,\n+  arrowElement: ExcalidrawArrowElement,\n+  bindTarget: ExcalidrawBindableElement,\n   elementsMap: ElementsMap,\n   p: GlobalPoint,\n ): GlobalPoint => {\n-  const center = elementCenterPoint(element, elementsMap);\n-  const nonRotatedPoint = pointRotateRads(p, center, -element.angle as Radians);\n+  const center = elementCenterPoint(bindTarget, elementsMap);\n+  const nonRotatedPoint = pointRotateRads(\n+    p,\n+    center,\n+    -bindTarget.angle as Radians,\n+  );\n \n-  if (nonRotatedPoint[0] < element.x && nonRotatedPoint[1] < element.y) {\n+  const bindingGap = getBindingGap(bindTarget, arrowElement);\n+\n+  if (nonRotatedPoint[0] < bindTarget.x && nonRotatedPoint[1] < bindTarget.y) {\n     // Top left\n-    if (nonRotatedPoint[1] - element.y > -FIXED_BINDING_DISTANCE) {\n+    if (nonRotatedPoint[1] - bindTarget.y > -bindingGap) {\n       return pointRotateRads<GlobalPoint>(\n-        pointFrom(element.x - FIXED_BINDING_DISTANCE, element.y),\n+        pointFrom(bindTarget.x - bindingGap, bindTarget.y),\n         center,\n-        element.angle,\n+        bindTarget.angle,\n       );\n     }\n     return pointRotateRads(\n-      pointFrom(element.x, element.y - FIXED_BINDING_DISTANCE),\n+      pointFrom(bindTarget.x, bindTarget.y - bindingGap),\n       center,\n-      element.angle,\n+      bindTarget.angle,\n     );\n   } else if (\n-    nonRotatedPoint[0] < element.x &&\n-    nonRotatedPoint[1] > element.y + element.height\n+    nonRotatedPoint[0] < bindTarget.x &&\n+    nonRotatedPoint[1] > bindTarget.y + bindTarget.height\n   ) {\n     // Bottom left\n-    if (nonRotatedPoint[0] - element.x > -FIXED_BINDING_DISTANCE) {\n+    if (nonRotatedPoint[0] - bindTarget.x > -bindingGap) {\n       return pointRotateRads(\n-        pointFrom(\n-          element.x,\n-          element.y + element.height + FIXED_BINDING_DISTANCE,\n-        ),\n+        pointFrom(bindTarget.x, bindTarget.y + bindTarget.height + bindingGap),\n         center,\n-        element.angle,\n+        bindTarget.angle,\n       );\n     }\n     return pointRotateRads(\n-      pointFrom(element.x - FIXED_BINDING_DISTANCE, element.y + element.height),\n+      pointFrom(bindTarget.x - bindingGap, bindTarget.y + bindTarget.height),\n       center,\n-      element.angle,\n+      bindTarget.angle,\n     );\n   } else if (\n-    nonRotatedPoint[0] > element.x + element.width &&\n-    nonRotatedPoint[1] > element.y + element.height\n+    nonRotatedPoint[0] > bindTarget.x + bindTarget.width &&\n+    nonRotatedPoint[1] > bindTarget.y + bindTarget.height\n   ) {\n     // Bottom right\n-    if (\n-      nonRotatedPoint[0] - element.x <\n-      element.width + FIXED_BINDING_DISTANCE\n-    ) {\n+    if (nonRotatedPoint[0] - bindTarget.x < bindTarget.width + bindingGap) {\n       return pointRotateRads(\n         pointFrom(\n-          element.x + element.width,\n-          element.y + element.height + FIXED_BINDING_DISTANCE,\n+          bindTarget.x + bindTarget.width,\n+          bindTarget.y + bindTarget.height + bindingGap,\n         ),\n         center,\n-        element.angle,\n+        bindTarget.angle,\n       );\n     }\n     return pointRotateRads(\n       pointFrom(\n-        element.x + element.width + FIXED_BINDING_DISTANCE,\n-        element.y + element.height,\n+        bindTarget.x + bindTarget.width + bindingGap,\n+        bindTarget.y + bindTarget.height,\n       ),\n       center,\n-      element.angle,\n+      bindTarget.angle,\n     );\n   } else if (\n-    nonRotatedPoint[0] > element.x + element.width &&\n-    nonRotatedPoint[1] < element.y\n+    nonRotatedPoint[0] > bindTarget.x + bindTarget.width &&\n+    nonRotatedPoint[1] < bindTarget.y\n   ) {\n     // Top right\n-    if (\n-      nonRotatedPoint[0] - element.x <\n-      element.width + FIXED_BINDING_DISTANCE\n-    ) {\n+    if (nonRotatedPoint[0] - bindTarget.x < bindTarget.width + bindingGap) {\n       return pointRotateRads(\n-        pointFrom(\n-          element.x + element.width,\n-          element.y - FIXED_BINDING_DISTANCE,\n-        ),\n+        pointFrom(bindTarget.x + bindTarget.width, bindTarget.y - bindingGap),\n         center,\n-        element.angle,\n+        bindTarget.angle,\n       );\n     }\n     return pointRotateRads(\n-      pointFrom(element.x + element.width + FIXED_BINDING_DISTANCE, element.y),\n+      pointFrom(bindTarget.x + bindTarget.width + bindingGap, bindTarget.y),\n       center,\n-      element.angle,\n+      bindTarget.angle,\n     );\n   }\n \n   return p;\n };\n \n-export const snapToMid = (\n-  element: ExcalidrawBindableElement,\n+const snapToMid = (\n+  arrowElement: ExcalidrawArrowElement,\n+  bindTarget: ExcalidrawBindableElement,\n   elementsMap: ElementsMap,\n   p: GlobalPoint,\n   tolerance: number = 0.05,\n ): GlobalPoint => {\n-  const { x, y, width, height, angle } = element;\n-  const center = elementCenterPoint(element, elementsMap, -0.1, -0.1);\n+  const { x, y, width, height, angle } = bindTarget;\n+  const center = elementCenterPoint(bindTarget, elementsMap, -0.1, -0.1);\n   const nonRotated = pointRotateRads(p, center, -angle as Radians);\n \n+  const bindingGap = getBindingGap(bindTarget, arrowElement);\n+\n   // snap-to-center point is adaptive to element size, but we don't want to go\n   // above and below certain px distance\n   const verticalThreshold = clamp(tolerance * height, 5, 80);\n   const horizontalThreshold = clamp(tolerance * width, 5, 80);\n \n+  // Too close to the center makes it hard to resolve direction precisely\n+  if (pointDistance(center, nonRotated) < bindingGap) {\n+    return p;\n+  }\n+\n   if (\n     nonRotated[0] <= x + width / 2 &&\n     nonRotated[1] > center[1] - verticalThreshold &&\n@@ -1173,7 +1451,7 @@ export const snapToMid = (\n   ) {\n     // LEFT\n     return pointRotateRads<GlobalPoint>(\n-      pointFrom(x - FIXED_BINDING_DISTANCE, center[1]),\n+      pointFrom(x - bindingGap, center[1]),\n       center,\n       angle,\n     );\n@@ -1183,11 +1461,7 @@ export const snapToMid = (\n     nonRotated[0] < center[0] + horizontalThreshold\n   ) {\n     // TOP\n-    return pointRotateRads(\n-      pointFrom(center[0], y - FIXED_BINDING_DISTANCE),\n-      center,\n-      angle,\n-    );\n+    return pointRotateRads(pointFrom(center[0], y - bindingGap), center, angle);\n   } else if (\n     nonRotated[0] >= x + width / 2 &&\n     nonRotated[1] > center[1] - verticalThreshold &&\n@@ -1195,7 +1469,7 @@ export const snapToMid = (\n   ) {\n     // RIGHT\n     return pointRotateRads(\n-      pointFrom(x + width + FIXED_BINDING_DISTANCE, center[1]),\n+      pointFrom(x + width + bindingGap, center[1]),\n       center,\n       angle,\n     );\n@@ -1206,12 +1480,12 @@ export const snapToMid = (\n   ) {\n     // DOWN\n     return pointRotateRads(\n-      pointFrom(center[0], y + height + FIXED_BINDING_DISTANCE),\n+      pointFrom(center[0], y + height + bindingGap),\n       center,\n       angle,\n     );\n-  } else if (element.type === \"diamond\") {\n-    const distance = FIXED_BINDING_DISTANCE;\n+  } else if (bindTarget.type === \"diamond\") {\n+    const distance = bindingGap;\n     const topLeft = pointFrom<GlobalPoint>(\n       x + width / 4 - distance,\n       y + height / 4 - distance,\n@@ -1258,131 +1532,174 @@ export const snapToMid = (\n   return p;\n };\n \n-const updateBoundPoint = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n+const compareElementArea = (\n+  a: ExcalidrawBindableElement,\n+  b: ExcalidrawBindableElement,\n+) => b.width ** 2 + b.height ** 2 - (a.width ** 2 + a.height ** 2);\n+\n+export const updateBoundPoint = (\n+  arrow: NonDeleted<ExcalidrawArrowElement>,\n   startOrEnd: \"startBinding\" | \"endBinding\",\n-  binding: PointBinding | null | undefined,\n+  binding: FixedPointBinding | null | undefined,\n   bindableElement: ExcalidrawBindableElement,\n   elementsMap: ElementsMap,\n+  customIntersector?: LineSegment<GlobalPoint>,\n ): LocalPoint | null => {\n   if (\n     binding == null ||\n     // We only need to update the other end if this is a 2 point line element\n-    (binding.elementId !== bindableElement.id &&\n-      linearElement.points.length > 2)\n+    (binding.elementId !== bindableElement.id && arrow.points.length > 2)\n   ) {\n     return null;\n   }\n \n-  const direction = startOrEnd === \"startBinding\" ? -1 : 1;\n-  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n-\n-  if (isElbowArrow(linearElement) && isFixedPointBinding(binding)) {\n-    const fixedPoint =\n-      normalizeFixedPoint(binding.fixedPoint) ??\n-      calculateFixedPointForElbowArrowBinding(\n-        linearElement,\n-        bindableElement,\n-        startOrEnd === \"startBinding\" ? \"start\" : \"end\",\n-        elementsMap,\n-      ).fixedPoint;\n-    const globalMidPoint = elementCenterPoint(bindableElement, elementsMap);\n-    const global = pointFrom<GlobalPoint>(\n-      bindableElement.x + fixedPoint[0] * bindableElement.width,\n-      bindableElement.y + fixedPoint[1] * bindableElement.height,\n+  const global = getGlobalFixedPointForBindableElement(\n+    normalizeFixedPoint(binding.fixedPoint),\n+    bindableElement,\n+    elementsMap,\n+  );\n+  const pointIndex =\n+    startOrEnd === \"startBinding\" ? 0 : arrow.points.length - 1;\n+  const elbowed = isElbowArrow(arrow);\n+  const otherBinding =\n+    startOrEnd === \"startBinding\" ? arrow.endBinding : arrow.startBinding;\n+  const otherBindableElement =\n+    otherBinding &&\n+    (elementsMap.get(otherBinding.elementId)! as ExcalidrawBindableElement);\n+  const bounds = getElementBounds(bindableElement, elementsMap);\n+  const otherBounds =\n+    otherBindableElement && getElementBounds(otherBindableElement, elementsMap);\n+  const isLargerThanOther =\n+    otherBindableElement &&\n+    compareElementArea(bindableElement, otherBindableElement) <\n+      // if both shapes the same size, pretend the other is larger\n+      (startOrEnd === \"endBinding\" ? 1 : 0);\n+  const isOverlapping = otherBounds && doBoundsIntersect(bounds, otherBounds);\n+\n+  // GOAL: If the arrow becomes too short, we want to jump the arrow endpoints\n+  // to the exact focus points on the elements.\n+  // INTUITION: We're not interested in the exacts length of the arrow (which\n+  // will change if we change where we route it), we want to know the length of\n+  // the part which lies outside of both shapes and consider that as a trigger\n+  // to change where we point the arrow. Avoids jumping the arrow in and out\n+  // at every frame.\n+  let arrowTooShort = false;\n+  if (\n+    !isOverlapping &&\n+    !elbowed &&\n+    arrow.startBinding &&\n+    arrow.endBinding &&\n+    otherBindableElement &&\n+    arrow.points.length === 2\n+  ) {\n+    const startFocusPoint = getGlobalFixedPointForBindableElement(\n+      arrow.startBinding.fixedPoint,\n+      startOrEnd === \"startBinding\" ? bindableElement : otherBindableElement,\n+      elementsMap,\n     );\n-    const rotatedGlobal = pointRotateRads(\n-      global,\n-      globalMidPoint,\n-      bindableElement.angle,\n+    const endFocusPoint = getGlobalFixedPointForBindableElement(\n+      arrow.endBinding.fixedPoint,\n+      startOrEnd === \"endBinding\" ? bindableElement : otherBindableElement,\n+      elementsMap,\n     );\n-\n-    return LinearElementEditor.pointFromAbsoluteCoords(\n-      linearElement,\n-      rotatedGlobal,\n+    const segment = lineSegment(startFocusPoint, endFocusPoint);\n+    const startIntersection = intersectElementWithLineSegment(\n+      startOrEnd === \"endBinding\" ? bindableElement : otherBindableElement,\n       elementsMap,\n+      segment,\n+      0,\n+      true,\n     );\n+    const endIntersection = intersectElementWithLineSegment(\n+      startOrEnd === \"startBinding\" ? bindableElement : otherBindableElement,\n+      elementsMap,\n+      segment,\n+      0,\n+      true,\n+    );\n+    if (startIntersection.length > 0 && endIntersection.length > 0) {\n+      const len = pointDistance(startIntersection[0], endIntersection[0]);\n+      arrowTooShort = len < 40;\n+    }\n   }\n \n-  const adjacentPointIndex = edgePointIndex - direction;\n-  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n-    linearElement,\n-    adjacentPointIndex,\n-    elementsMap,\n-  );\n-  const focusPointAbsolute = determineFocusPoint(\n-    bindableElement,\n-    elementsMap,\n-    binding.focus,\n-    adjacentPoint,\n-  );\n-\n-  let newEdgePoint: GlobalPoint;\n-\n-  // The linear element was not originally pointing inside the bound shape,\n-  // we can point directly at the focus point\n-  if (binding.gap === 0) {\n-    newEdgePoint = focusPointAbsolute;\n-  } else {\n-    const edgePointAbsolute =\n-      LinearElementEditor.getPointAtIndexGlobalCoordinates(\n-        linearElement,\n-        edgePointIndex,\n-        elementsMap,\n-      );\n+  const isNested = (arrowTooShort || isOverlapping) && isLargerThanOther;\n \n-    const center = elementCenterPoint(bindableElement, elementsMap);\n-    const interceptorLength =\n-      pointDistance(adjacentPoint, edgePointAbsolute) +\n-      pointDistance(adjacentPoint, center) +\n-      Math.max(bindableElement.width, bindableElement.height) * 2;\n-    const intersections = [\n-      ...intersectElementWithLineSegment(\n-        bindableElement,\n-        elementsMap,\n-        lineSegment<GlobalPoint>(\n-          adjacentPoint,\n-          pointFromVector(\n-            vectorScale(\n-              vectorNormalize(\n-                vectorFromPoint(focusPointAbsolute, adjacentPoint),\n-              ),\n-              interceptorLength,\n-            ),\n-            adjacentPoint,\n-          ),\n-        ),\n-        binding.gap,\n-      ).sort(\n-        (g, h) =>\n-          pointDistanceSq(g, adjacentPoint) - pointDistanceSq(h, adjacentPoint),\n-      ),\n-      // Fallback when arrow doesn't point to the shape\n-      pointFromVector(\n-        vectorScale(\n-          vectorNormalize(vectorFromPoint(focusPointAbsolute, adjacentPoint)),\n-          pointDistance(adjacentPoint, edgePointAbsolute),\n-        ),\n-        adjacentPoint,\n+  let _customIntersector = customIntersector;\n+  if (!elbowed && !_customIntersector) {\n+    const [x1, y1, x2, y2] = LinearElementEditor.getElementAbsoluteCoords(\n+      arrow,\n+      elementsMap,\n+    );\n+    const center = pointFrom<GlobalPoint>((x1 + x2) / 2, (y1 + y2) / 2);\n+    const edgePoint = isRectanguloidElement(bindableElement)\n+      ? avoidRectangularCorner(arrow, bindableElement, elementsMap, global)\n+      : global;\n+    const adjacentPoint = pointRotateRads(\n+      pointFrom<GlobalPoint>(\n+        arrow.x +\n+          arrow.points[pointIndex === 0 ? 1 : arrow.points.length - 2][0],\n+        arrow.y +\n+          arrow.points[pointIndex === 0 ? 1 : arrow.points.length - 2][1],\n       ),\n-    ];\n-\n-    if (intersections.length > 1) {\n-      // The adjacent point is outside the shape (+ gap)\n-      newEdgePoint = intersections[0];\n-    } else if (intersections.length === 1) {\n-      // The adjacent point is inside the shape (+ gap)\n-      newEdgePoint = focusPointAbsolute;\n-    } else {\n-      // Shouldn't happend, but just in case\n-      newEdgePoint = edgePointAbsolute;\n-    }\n+      center,\n+      arrow.angle as Radians,\n+    );\n+    const bindingGap = getBindingGap(bindableElement, arrow);\n+    const halfVector = vectorScale(\n+      vectorNormalize(vectorFromPoint(edgePoint, adjacentPoint)),\n+      pointDistance(edgePoint, adjacentPoint) +\n+        Math.max(bindableElement.width, bindableElement.height) +\n+        bindingGap * 2,\n+    );\n+    _customIntersector = lineSegment(\n+      pointFromVector(halfVector, adjacentPoint),\n+      pointFromVector(vectorScale(halfVector, -1), adjacentPoint),\n+    );\n   }\n \n-  return LinearElementEditor.pointFromAbsoluteCoords(\n-    linearElement,\n-    newEdgePoint,\n+  const maybeOutlineGlobal =\n+    binding.mode === \"orbit\" && bindableElement\n+      ? isNested\n+        ? global\n+        : bindPointToSnapToElementOutline(\n+            {\n+              ...arrow,\n+              points: [\n+                pointIndex === 0\n+                  ? LinearElementEditor.createPointAt(\n+                      arrow,\n+                      elementsMap,\n+                      global[0],\n+                      global[1],\n+                      null,\n+                    )\n+                  : arrow.points[0],\n+                ...arrow.points.slice(1, -1),\n+                pointIndex === arrow.points.length - 1\n+                  ? LinearElementEditor.createPointAt(\n+                      arrow,\n+                      elementsMap,\n+                      global[0],\n+                      global[1],\n+                      null,\n+                    )\n+                  : arrow.points[arrow.points.length - 1],\n+              ],\n+            },\n+            bindableElement,\n+            pointIndex === 0 ? \"start\" : \"end\",\n+            elementsMap,\n+            _customIntersector,\n+          )\n+      : global;\n+\n+  return LinearElementEditor.createPointAt(\n+    arrow,\n     elementsMap,\n+    maybeOutlineGlobal[0],\n+    maybeOutlineGlobal[1],\n+    null,\n   );\n };\n \n@@ -1424,58 +1741,43 @@ export const calculateFixedPointForElbowArrowBinding = (\n   };\n };\n \n-const maybeCalculateNewGapWhenScaling = (\n-  changedElement: ExcalidrawBindableElement,\n-  currentBinding: PointBinding | null | undefined,\n-  newSize: { width: number; height: number } | undefined,\n-): PointBinding | null | undefined => {\n-  if (currentBinding == null || newSize == null) {\n-    return currentBinding;\n-  }\n-  const { width: newWidth, height: newHeight } = newSize;\n-  const { width, height } = changedElement;\n-  const newGap = Math.max(\n-    1,\n-    Math.min(\n-      maxBindingGap(changedElement, newWidth, newHeight),\n-      currentBinding.gap *\n-        (newWidth < newHeight ? newWidth / width : newHeight / height),\n-    ),\n-  );\n-\n-  return { ...currentBinding, gap: newGap };\n-};\n-\n-const getEligibleElementForBindingElement = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n+export const calculateFixedPointForNonElbowArrowBinding = (\n+  linearElement: NonDeleted<ExcalidrawArrowElement>,\n+  hoveredElement: ExcalidrawBindableElement,\n   startOrEnd: \"start\" | \"end\",\n-  elementsMap: NonDeletedSceneElementsMap,\n-  elements: readonly NonDeletedExcalidrawElement[],\n-  zoom?: AppState[\"zoom\"],\n-): NonDeleted<ExcalidrawBindableElement> | null => {\n-  return getHoveredElementForBinding(\n-    getLinearElementEdgeCoors(linearElement, startOrEnd, elementsMap),\n-    elements,\n-    elementsMap,\n-    zoom,\n-    isElbowArrow(linearElement),\n-    isElbowArrow(linearElement),\n+  elementsMap: ElementsMap,\n+  focusPoint?: GlobalPoint,\n+): { fixedPoint: FixedPoint } => {\n+  const edgePoint = focusPoint\n+    ? focusPoint\n+    : LinearElementEditor.getPointAtIndexGlobalCoordinates(\n+        linearElement,\n+        startOrEnd === \"start\" ? 0 : -1,\n+        elementsMap,\n+      );\n+\n+  // Convert the global point to element-local coordinates\n+  const elementCenter = pointFrom(\n+    hoveredElement.x + hoveredElement.width / 2,\n+    hoveredElement.y + hoveredElement.height / 2,\n   );\n-};\n \n-const getLinearElementEdgeCoors = (\n-  linearElement: NonDeleted<ExcalidrawLinearElement>,\n-  startOrEnd: \"start\" | \"end\",\n-  elementsMap: NonDeletedSceneElementsMap,\n-): { x: number; y: number } => {\n-  const index = startOrEnd === \"start\" ? 0 : -1;\n-  return tupleToCoors(\n-    LinearElementEditor.getPointAtIndexGlobalCoordinates(\n-      linearElement,\n-      index,\n-      elementsMap,\n-    ),\n+  // Rotate the point to account for element rotation\n+  const nonRotatedPoint = pointRotateRads(\n+    edgePoint,\n+    elementCenter,\n+    -hoveredElement.angle as Radians,\n   );\n+\n+  // Calculate the ratio relative to the element's bounds\n+  const fixedPointX =\n+    (nonRotatedPoint[0] - hoveredElement.x) / hoveredElement.width;\n+  const fixedPointY =\n+    (nonRotatedPoint[1] - hoveredElement.y) / hoveredElement.height;\n+\n+  return {\n+    fixedPoint: normalizeFixedPoint([fixedPointX, fixedPointY]),\n+  };\n };\n \n export const fixDuplicatedBindingsAfterDuplication = (\n@@ -1591,324 +1893,6 @@ const newBoundElements = (\n   return nextBoundElements;\n };\n \n-export const bindingBorderTest = (\n-  element: NonDeleted<ExcalidrawBindableElement>,\n-  { x, y }: { x: number; y: number },\n-  elementsMap: NonDeletedSceneElementsMap,\n-  zoom?: AppState[\"zoom\"],\n-  fullShape?: boolean,\n-): boolean => {\n-  const p = pointFrom<GlobalPoint>(x, y);\n-  const threshold = maxBindingGap(element, element.width, element.height, zoom);\n-  const shouldTestInside =\n-    // disable fullshape snapping for frame elements so we\n-    // can bind to frame children\n-    (fullShape || !isBindingFallthroughEnabled(element)) &&\n-    !isFrameLikeElement(element);\n-\n-  // PERF: Run a cheap test to see if the binding element\n-  // is even close to the element\n-  const bounds = [\n-    x - threshold,\n-    y - threshold,\n-    x + threshold,\n-    y + threshold,\n-  ] as Bounds;\n-  const elementBounds = getElementBounds(element, elementsMap);\n-  if (!doBoundsIntersect(bounds, elementBounds)) {\n-    return false;\n-  }\n-\n-  // Do the intersection test against the element since it's close enough\n-  const intersections = intersectElementWithLineSegment(\n-    element,\n-    elementsMap,\n-    lineSegment(elementCenterPoint(element, elementsMap), p),\n-  );\n-  const distance = distanceToElement(element, elementsMap, p);\n-\n-  return shouldTestInside\n-    ? intersections.length === 0 || distance <= threshold\n-    : intersections.length > 0 && distance <= threshold;\n-};\n-\n-export const maxBindingGap = (\n-  element: ExcalidrawElement,\n-  elementWidth: number,\n-  elementHeight: number,\n-  zoom?: AppState[\"zoom\"],\n-): number => {\n-  const zoomValue = zoom?.value && zoom.value < 1 ? zoom.value : 1;\n-\n-  // Aligns diamonds with rectangles\n-  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n-  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n-\n-  return Math.max(\n-    16,\n-    // bigger bindable boundary for bigger elements\n-    Math.min(0.25 * smallerDimension, 32),\n-    // keep in sync with the zoomed highlight\n-    BINDING_HIGHLIGHT_THICKNESS / zoomValue + FIXED_BINDING_DISTANCE,\n-  );\n-};\n-\n-// The focus distance is the oriented ratio between the size of\n-// the `element` and the \"focus image\" of the element on which\n-// all focus points lie, so it's a number between -1 and 1.\n-// The line going through `a` and `b` is a tangent to the \"focus image\"\n-// of the element.\n-const determineFocusDistance = (\n-  element: ExcalidrawBindableElement,\n-  elementsMap: ElementsMap,\n-  // Point on the line, in absolute coordinates\n-  a: GlobalPoint,\n-  // Another point on the line, in absolute coordinates (closer to element)\n-  b: GlobalPoint,\n-): number => {\n-  const center = elementCenterPoint(element, elementsMap);\n-\n-  if (pointsEqual(a, b)) {\n-    return 0;\n-  }\n-\n-  const rotatedA = pointRotateRads(a, center, -element.angle as Radians);\n-  const rotatedB = pointRotateRads(b, center, -element.angle as Radians);\n-  const sign =\n-    Math.sign(\n-      vectorCross(\n-        vectorFromPoint(rotatedB, a),\n-        vectorFromPoint(rotatedB, center),\n-      ),\n-    ) * -1;\n-  const rotatedInterceptor = lineSegment(\n-    rotatedB,\n-    pointFromVector(\n-      vectorScale(\n-        vectorNormalize(vectorFromPoint(rotatedB, rotatedA)),\n-        Math.max(element.width * 2, element.height * 2),\n-      ),\n-      rotatedB,\n-    ),\n-  );\n-  const axes =\n-    element.type === \"diamond\"\n-      ? [\n-          lineSegment(\n-            pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n-            pointFrom<GlobalPoint>(\n-              element.x + element.width / 2,\n-              element.y + element.height,\n-            ),\n-          ),\n-          lineSegment(\n-            pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n-            pointFrom<GlobalPoint>(\n-              element.x + element.width,\n-              element.y + element.height / 2,\n-            ),\n-          ),\n-        ]\n-      : [\n-          lineSegment(\n-            pointFrom<GlobalPoint>(element.x, element.y),\n-            pointFrom<GlobalPoint>(\n-              element.x + element.width,\n-              element.y + element.height,\n-            ),\n-          ),\n-          lineSegment(\n-            pointFrom<GlobalPoint>(element.x + element.width, element.y),\n-            pointFrom<GlobalPoint>(element.x, element.y + element.height),\n-          ),\n-        ];\n-  const interceptees =\n-    element.type === \"diamond\"\n-      ? [\n-          lineSegment(\n-            pointFrom<GlobalPoint>(\n-              element.x + element.width / 2,\n-              element.y - element.height,\n-            ),\n-            pointFrom<GlobalPoint>(\n-              element.x + element.width / 2,\n-              element.y + element.height * 2,\n-            ),\n-          ),\n-          lineSegment(\n-            pointFrom<GlobalPoint>(\n-              element.x - element.width,\n-              element.y + element.height / 2,\n-            ),\n-            pointFrom<GlobalPoint>(\n-              element.x + element.width * 2,\n-              element.y + element.height / 2,\n-            ),\n-          ),\n-        ]\n-      : [\n-          lineSegment(\n-            pointFrom<GlobalPoint>(\n-              element.x - element.width,\n-              element.y - element.height,\n-            ),\n-            pointFrom<GlobalPoint>(\n-              element.x + element.width * 2,\n-              element.y + element.height * 2,\n-            ),\n-          ),\n-          lineSegment(\n-            pointFrom<GlobalPoint>(\n-              element.x + element.width * 2,\n-              element.y - element.height,\n-            ),\n-            pointFrom<GlobalPoint>(\n-              element.x - element.width,\n-              element.y + element.height * 2,\n-            ),\n-          ),\n-        ];\n-\n-  const ordered = [\n-    lineSegmentIntersectionPoints(rotatedInterceptor, interceptees[0]),\n-    lineSegmentIntersectionPoints(rotatedInterceptor, interceptees[1]),\n-  ]\n-    .filter((p): p is GlobalPoint => p !== null)\n-    .sort((g, h) => pointDistanceSq(g, b) - pointDistanceSq(h, b))\n-    .map(\n-      (p, idx): number =>\n-        (sign * pointDistance(center, p)) /\n-        (element.type === \"diamond\"\n-          ? pointDistance(axes[idx][0], axes[idx][1]) / 2\n-          : Math.sqrt(element.width ** 2 + element.height ** 2) / 2),\n-    )\n-    .sort((g, h) => Math.abs(g) - Math.abs(h));\n-\n-  const signedDistanceRatio = ordered[0] ?? 0;\n-\n-  return signedDistanceRatio;\n-};\n-\n-const determineFocusPoint = (\n-  element: ExcalidrawBindableElement,\n-  elementsMap: ElementsMap,\n-  // The oriented, relative distance from the center of `element` of the\n-  // returned focusPoint\n-  focus: number,\n-  adjacentPoint: GlobalPoint,\n-): GlobalPoint => {\n-  const center = elementCenterPoint(element, elementsMap);\n-\n-  if (focus === 0) {\n-    return center;\n-  }\n-\n-  const candidates = (\n-    element.type === \"diamond\"\n-      ? [\n-          pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n-          pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n-          pointFrom<GlobalPoint>(\n-            element.x + element.width,\n-            element.y + element.height / 2,\n-          ),\n-          pointFrom<GlobalPoint>(\n-            element.x + element.width / 2,\n-            element.y + element.height,\n-          ),\n-        ]\n-      : [\n-          pointFrom<GlobalPoint>(element.x, element.y),\n-          pointFrom<GlobalPoint>(element.x + element.width, element.y),\n-          pointFrom<GlobalPoint>(\n-            element.x + element.width,\n-            element.y + element.height,\n-          ),\n-          pointFrom<GlobalPoint>(element.x, element.y + element.height),\n-        ]\n-  )\n-    .map((p) =>\n-      pointFromVector(\n-        vectorScale(vectorFromPoint(p, center), Math.abs(focus)),\n-        center,\n-      ),\n-    )\n-    .map((p) => pointRotateRads(p, center, element.angle as Radians));\n-\n-  const selected = [\n-    vectorCross(\n-      vectorFromPoint(adjacentPoint, candidates[0]),\n-      vectorFromPoint(candidates[1], candidates[0]),\n-    ) > 0 && // TOP\n-      (focus > 0\n-        ? vectorCross(\n-            vectorFromPoint(adjacentPoint, candidates[1]),\n-            vectorFromPoint(candidates[2], candidates[1]),\n-          ) < 0\n-        : vectorCross(\n-            vectorFromPoint(adjacentPoint, candidates[3]),\n-            vectorFromPoint(candidates[0], candidates[3]),\n-          ) < 0),\n-    vectorCross(\n-      vectorFromPoint(adjacentPoint, candidates[1]),\n-      vectorFromPoint(candidates[2], candidates[1]),\n-    ) > 0 && // RIGHT\n-      (focus > 0\n-        ? vectorCross(\n-            vectorFromPoint(adjacentPoint, candidates[2]),\n-            vectorFromPoint(candidates[3], candidates[2]),\n-          ) < 0\n-        : vectorCross(\n-            vectorFromPoint(adjacentPoint, candidates[0]),\n-            vectorFromPoint(candidates[1], candidates[0]),\n-          ) < 0),\n-    vectorCross(\n-      vectorFromPoint(adjacentPoint, candidates[2]),\n-      vectorFromPoint(candidates[3], candidates[2]),\n-    ) > 0 && // BOTTOM\n-      (focus > 0\n-        ? vectorCross(\n-            vectorFromPoint(adjacentPoint, candidates[3]),\n-            vectorFromPoint(candidates[0], candidates[3]),\n-          ) < 0\n-        : vectorCross(\n-            vectorFromPoint(adjacentPoint, candidates[1]),\n-            vectorFromPoint(candidates[2], candidates[1]),\n-          ) < 0),\n-    vectorCross(\n-      vectorFromPoint(adjacentPoint, candidates[3]),\n-      vectorFromPoint(candidates[0], candidates[3]),\n-    ) > 0 && // LEFT\n-      (focus > 0\n-        ? vectorCross(\n-            vectorFromPoint(adjacentPoint, candidates[0]),\n-            vectorFromPoint(candidates[1], candidates[0]),\n-          ) < 0\n-        : vectorCross(\n-            vectorFromPoint(adjacentPoint, candidates[2]),\n-            vectorFromPoint(candidates[3], candidates[2]),\n-          ) < 0),\n-  ];\n-\n-  const focusPoint = selected[0]\n-    ? focus > 0\n-      ? candidates[1]\n-      : candida",
			"diffSize": 654997,
			"diffTruncated": true,
			"filterResult": {
				"included": true
			}
		}
	]
}
